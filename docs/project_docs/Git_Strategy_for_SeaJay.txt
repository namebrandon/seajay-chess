Git Branch Management for SeaJay Development / OpenBench Testing

  CRITICAL DIRECTIVE

  - Commit and push after each logical change so OpenBench SPRT runs can isolate regressions to a single revision. Bundled changes
    without validation are prohibited.

  Overview

  When using OpenBench for chess engine testing (which is a core function in SeaJay development), descriptive branch names are essential for readable test identification. Instead of
  seeing cryptic test names like "fd3d575e vs b949c42", you'll see meaningful names like "feature/20250819-null-move vs main".

  Branch Naming Convention

  Directory Structure

  origin/
  ├── main                        # Primary development branch
  ├── feature/                    # New functionality
  │   └── YYYYMMDD-description
  ├── bugfix/                     # Bug fixes
  │   └── YYYYMMDD-description
  ├── test/                       # Experimental changes
  │   └── YYYYMMDD-description
  ├── tune/                       # Parameter tuning (SPSA)
  │   └── YYYYMMDD-description
  ├── integration/                # Features with unmet dependencies
  │   └── description            # Long-lived branches awaiting prerequisites
  └── ob/                         # Historical reference builds
      └── YYYYMMDD-description

  Branch Categories

  | Prefix       | Purpose                    | Example                        | Lifecycle                        |
  |--------------|----------------------------|--------------------------------|----------------------------------|
  | feature/     | New functionality          | feature/20250819-pondering     | Merge to main if successful      |
  | bugfix/      | Bug fixes                  | bugfix/20250819-illegal-move   | Merge to main when fixed         |
  | test/        | Experimental ideas         | test/20250819-eval-tweak       | Delete after testing             |
  | tune/        | SPSA parameter tuning      | tune/20250819-piece-values     | Delete after tuning              |
  | integration/ | Features needing prereqs   | integration/lmr-with-ordering  | Long-lived, merge when ready     |
  | ob/          | Historical references      | ob/20250819-v1.0-release       | Keep long-term                   |

  Git Alias Setup

  1. Automated Installation (Recommended)

  A setup script is available for easy installation:

  # Run the automated setup script
  chmod +x /workspace/setup_git_aliases.sh
  ./setup_git_aliases.sh

  This script will install all aliases and provide verification that they're working correctly.

  2. Manual Installation

  Alternatively, you can run these commands individually to set up your Git environment:

  # Branch creation aliases
  git config --global alias.feature '!f() { git checkout -b feature/$(date +%Y%m%d)-$1 && git push -u origin feature/$(date 
  +%Y%m%d)-$1; }; f'
  git config --global alias.bugfix '!f() { git checkout -b bugfix/$(date +%Y%m%d)-$1 && git push -u origin bugfix/$(date +%Y%m%d)-$1; 
  }; f'
  git config --global alias.test '!f() { git checkout -b test/$(date +%Y%m%d)-$1 && git push -u origin test/$(date +%Y%m%d)-$1; }; f'
  git config --global alias.tune '!f() { git checkout -b tune/$(date +%Y%m%d)-$1 && git push -u origin tune/$(date +%Y%m%d)-$1; }; f'
  git config --global alias.ob '!f() { git checkout -b ob/$(date +%Y%m%d)-$1 && git push -u origin ob/$(date +%Y%m%d)-$1; }; f'

  # Branch listing aliases
  git config --global alias.list-features '!git branch -r | grep "origin/feature/"'
  git config --global alias.list-bugfix '!git branch -r | grep "origin/bugfix/"'
  git config --global alias.list-tests '!git branch -r | grep "origin/test/"'
  git config --global alias.list-tune '!git branch -r | grep "origin/tune/"'
  git config --global alias.list-ob '!git branch -r | grep "origin/ob/"'
  git config --global alias.list-all-branches '!git branch -r | grep -E "origin/(feature|bugfix|test|tune|ob)/" | sort'

  # Branch cleanup aliases (WARNING: These delete remote branches!)
  git config --global alias.clean-tests '!git branch -r | grep "origin/test/" | sed "s/origin\\///" | xargs -r -n 1 git push origin 
  --delete'
  git config --global alias.clean-bugfix '!git branch -r | grep "origin/bugfix/" | sed "s/origin\\///" | xargs -r -n 1 git push origin 
  --delete'
  git config --global alias.clean-features '!git branch -r | grep "origin/feature/" | sed "s/origin\\///" | xargs -r -n 1 git push 
  origin --delete'
  git config --global alias.clean-tune '!git branch -r | grep "origin/tune/" | sed "s/origin\\///" | xargs -r -n 1 git push origin 
  --delete'

  # Utility aliases
  git config --global alias.show-branch-age '!git for-each-ref --format="%(refname:short) %(committerdate:relative)" 
  refs/remotes/origin/ | grep -E "(feature|bugfix|test|tune|ob)/" | column -t'
  git config --global alias.clean-old-tests '!git for-each-ref --format="%(refname:short) %(committerdate:unix)" 
  refs/remotes/origin/test/ | while read branch date; do if [ $(($(date +%s) - date)) -gt 604800 ]; then echo "Deleting $branch"; git 
  push origin --delete ${branch#origin/}; fi; done'

  3. Verify Installation

  # Check that aliases were created
  git config --global --list | grep alias
  
  # Or run the setup script with verification
  ./setup_git_aliases.sh  # Includes automatic verification

  Usage Examples

  Creating Branches

  # Working on a new feature
  git feature null-move-pruning
  # Creates: feature/20250819-null-move-pruning

  # Fixing a bug
  git bugfix castling-rights
  # Creates: bugfix/20250819-castling-rights

  # Testing an experimental idea
  git test aggressive-lmr
  # Creates: test/20250819-aggressive-lmr

  # Running SPSA tuning
  git tune eval-weights
  # Creates: tune/20250819-eval-weights

  # Saving a historical reference
  git ob pre-refactor-baseline
  # Creates: ob/20250819-pre-refactor-baseline

  OpenBench Workflow

  1. Phased Feature Development (RECOMMENDED APPROACH)

  SeaJay follows a strict phased development model with frequent testing, even for 
  phases with no expected impact. This approach has proven highly successful for 
  catching bugs early and understanding performance impacts.

  Example: Implementing Killer Moves (Stage 19)
  
  Phase A1: Infrastructure Only (0 ELO expected)
  ================================================
  # Create feature branch
  git feature killer-moves

  # Implement just the data structures, no integration
  vim src/search/killer_moves.h src/search/killer_moves.cpp
  git add -A
  git commit -m "feat: Add killer moves infrastructure (Phase A1) - bench 19191913"
  git push

  # Test in OpenBench (expect 0 ELO change)
  # Dev Branch: feature/20250820-killer-moves
  # Base Branch: main
  # Result: Confirms no regression, infrastructure stable

  Phase A2: Integration Without Updates (+20-30 ELO expected)
  ===========================================================
  # Continue on same branch
  # Integrate into move ordering, but don't update the table yet
  vim src/search/move_ordering.cpp
  git add -A
  git commit -m "feat: Integrate killers in move ordering (Phase A2) - bench 19191913"
  git push

  # Test in OpenBench
  # Result: May show small change or regression due to overhead

  Phase A3: Full Implementation (+10 ELO additional expected)
  ===========================================================
  # Add the update logic
  vim src/search/negamax.cpp
  git add -A
  git commit -m "feat: Update killers on beta cutoffs (Phase A3) - bench 19191913"
  git push

  # Test in OpenBench
  # Result: Full ELO gain realized

  # After all phases pass, merge to main
  git checkout main
  git merge feature/20250820-killer-moves
  git push origin main

  CRITICAL: Why This Works
  ========================
  - Phase with "no impact" catch integration bugs early
  - Overhead phases (like B2: -9 ELO) are expected and documented
  - Each phase is independently testable
  - Bugs are isolated to specific commits
  - Performance regressions are immediately visible

  2. Standard Feature Development (Simple Features Only)

  2. Bug Fix

  # Create bugfix branch
  git bugfix en-passant-capture

  # Fix the bug
  vim src/movegen.cpp
  git add -A
  git commit -m "Fix en passant capture validation"

  # Test in OpenBench
  # Dev Branch: bugfix/20250819-en-passant-capture
  # Base Branch: main

  # After verification, merge and cleanup
  git checkout main
  git merge bugfix/20250819-en-passant-capture
  git push origin main
  git push origin --delete bugfix/20250819-en-passant-capture

  3. Experimental Testing

  # Quick experiment
  git test futility-pruning-v2

  # Make changes and commit
  git add -A
  git commit -m "Experimental futility pruning"

  # Test in OpenBench
  # Dev Branch: test/20250819-futility-pruning-v2
  # Base Branch: ob/20250815-stable-baseline

  # Whether it works or not, clean up test branches periodically
  git clean-tests  # Deletes ALL test branches - be careful!

  Branch Management

  # List branches by type
  git list-features      # Show all feature branches
  git list-tests         # Show all test branches
  git list-ob           # Show all historical references
  git list-all-branches  # Show everything organized

  # Check branch ages
  git show-branch-age    # Shows how old each branch is

  # Cleanup old branches
  git clean-tests        # Delete ALL test branches
  git clean-old-tests    # Delete test branches older than 7 days
  git clean-bugfix       # Delete ALL bugfix branches

  # WARNING: Never run git clean-ob unless you're sure!
  # Historical references should be kept long-term

  CRITICAL: Files That Should Never Be Tracked
  
  The following files/directories are development-specific and should NEVER be pushed to the repository:
  
  - CLAUDE.md         # AI assistant context file (contains sensitive project info)
  - .claude/          # Claude-specific configuration directory
  - .devcontainer/    # Local development container configuration
  - feature_status.md # Temporary feature tracking (lives on feature branches only)
  
  If these files are accidentally tracked (showing in git status as modified/deleted):
  
  # Remove them from git tracking while keeping local copies
  git rm --cached -r .claude .devcontainer CLAUDE.md feature_status.md
  
  # Commit the removal
  git commit -m "chore: Remove development-specific files from tracking
  
  These files should remain local only:
  - CLAUDE.md (AI context)
  - .claude/ (Claude config)
  - .devcontainer/ (dev environment)
  - feature_status.md (temporary tracking)
  
  bench 19191913"
  
  # Verify they're in .gitignore
  grep -E "(CLAUDE|\.claude|\.devcontainer|feature_status)" .gitignore
  
  IMPORTANT: These files are already in .gitignore, but if they were added to git
  BEFORE being gitignored, they'll continue to be tracked. The above commands fix this.
  
  Best Practices

  1. Phased Development Strategy (MANDATORY for complex features)

  Complex features MUST be broken into phases:
  
  Phase Structure:
  ================
  - Phase 1: Infrastructure (data structures, no integration)
    Expected: 0 ELO, validates compilation and basic structure
    
  - Phase 2: Integration (hook into engine, but minimal functionality)
    Expected: 0 to small negative ELO (overhead without benefit)
    
  - Phase 3: Activation (turn on the feature)
    Expected: Main ELO gain
    
  - Phase 4+: Refinements (tuning, optimizations)
    Expected: Incremental gains

  Commit Message Format:
  ======================
  ALWAYS include:
  - Phase identifier (Phase A1, B2, etc.)
  - Bench count for OpenBench
  - Expected impact
  
  Example:
  "feat: Add history heuristic infrastructure (Phase B1) - bench 19191913"

  Testing Requirements:
  =====================
  - EVERY phase gets OpenBench tested
  - Even 0 ELO phases (they catch bugs!)
  - Document expected regressions (like Phase B2: -9 ELO from overhead)
  - Wait for test completion before next phase
  - Use SPRT for statistical significance

  When to Use Phased Approach:
  =============================
  ALWAYS for:
  - Move ordering improvements (killers, history, countermoves)
  - Search enhancements (LMR, null move, extensions)
  - Evaluation features (complex positional terms)
  - Pruning techniques (futility, delta, razoring)
  
  OPTIONAL for:
  - Bug fixes (unless complex)
  - Simple parameter changes
  - UCI additions
  - Display improvements

  2. Branch Lifecycle

  - feature/ - Merge to main if successful, then delete
  - bugfix/ - Merge to main when fixed, then delete
  - test/ - Delete after testing (pass or fail)
  - tune/ - Delete after tuning run completes
  - ob/ - Keep indefinitely as historical references

  2. Historical References (ob/)

  Create ob/ branches for:
  - Release versions (ob/20250819-v1.0-release)
  - Significant milestones (ob/20250819-elo-2000)
  - Before major refactoring (ob/20250819-pre-refactor)
  - Stable baselines for testing (ob/20250819-stable-baseline)

  3. Cleanup Strategy

  # Weekly cleanup routine
  git list-all-branches      # Review what you have
  git show-branch-age        # Check ages
  git clean-old-tests        # Auto-cleanup old test branches
  git list-bugfix           # Manually review bugfix branches
  git list-features         # Manually review feature branches

  4. OpenBench Testing Tips

  - Always use branch names, not commit SHAs
  - Create the branch BEFORE starting the OpenBench test
  - Push the branch immediately after creation (the aliases do this automatically)
  - Use meaningful descriptions after the date
  - ALWAYS include bench count in commit messages for OpenBench compatibility

  5. Success Metrics for Phased Development

  Phase Success Criteria:
  =======================
  - Infrastructure phases: No regression (0 ELO ± confidence interval)
  - Integration phases: Expected regression documented and observed
  - Activation phases: Positive ELO gain within expected range
  - All phases: Clean compilation, no warnings, tests pass

  Real Examples from SeaJay:
  ==========================
  Killer Moves (Stage 19):
  - Phase A1 (infrastructure): 0.00 ± 10.33 ELO ✓ (as expected)
  - Phase A2 (integration): Minimal change ✓
  - Phase A3 (activation): +31.42 ± 10.49 ELO ✓ (expected 30-40)
  
  History Heuristic (Stage 20):
  - Phase B1 (infrastructure): 0 ELO ✓ (as expected)
  - Phase B2 (integration): -9.14 ± 7.51 ELO ✓ (expected -5 to -10)
  - Phase B3 (activation): Testing in progress (expect +25-35 to recover)

  Installation Status

  After successful installation, you will have 17 Git aliases configured:
  - 5 branch creation aliases (feature, bugfix, test, tune, ob)
  - 6 branch listing aliases (list-features, list-bugfix, list-tests, list-tune, list-ob, list-all-branches)
  - 4 branch cleanup aliases (clean-tests, clean-bugfix, clean-features, clean-tune)
  - 2 utility aliases (show-branch-age, clean-old-tests)

  Troubleshooting

  Branch Already Exists

  If you get an error that a branch already exists:
  # Delete the old branch first
  git push origin --delete feature/20250819-some-feature
  # Then create it again
  git feature some-feature

  Can't Delete Branch

  If deletion fails because the branch is checked out:
  git checkout main
  git branch -D local-branch-name
  git push origin --delete remote-branch-name

  View Alias Definition

  To see what an alias does:
  git config --global --get alias.feature

  Integration with CLAUDE.md

  Add this to your CLAUDE.md file:

  ## Git Branch Management

  This project uses a structured branch naming convention for OpenBench testing:
  - `feature/YYYYMMDD-name` - New features
  - `bugfix/YYYYMMDD-name` - Bug fixes
  - `test/YYYYMMDD-name` - Experiments
  - `tune/YYYYMMDD-name` - SPSA tuning
  - `ob/YYYYMMDD-name` - Historical references

  Use Git aliases to create branches:
  - `git feature <name>` - Create feature branch
  - `git bugfix <name>` - Create bugfix branch
  - `git test <name>` - Create test branch
  - `git tune <name>` - Create tuning branch
  - `git ob <name>` - Create historical reference

  List branches with:
  - `git list-all-branches` - Show all organized branches
  - `git show-branch-age` - Show branch ages

  When creating OpenBench tests, use branch names (not commit SHAs) for readable test identification.

  ## Integration Branches - Advanced Feature Management

  Integration branches handle the common scenario where a feature is discovered to have unmet dependencies during implementation.

  ### When to Use Integration Branches

  Use integration/ branches when:
  - A feature is partially implemented but needs other features to work properly
  - Dependencies are discovered mid-implementation
  - You want to preserve work while building prerequisites
  - The feature is correct but cannot be fully tested/enabled yet

  ### Integration Branch Workflow

  #### Scenario: Feature with Discovered Dependencies

  ```bash
  # You're working on feature/20250820-lmr when you realize it needs move ordering
  git checkout feature/20250820-lmr

  # Step 1: Get the feature to a "correct but disabled" state
  # - Fix any bugs you've discovered
  # - Ensure it compiles and would work if dependencies existed
  # - Set feature to disabled by default
  git add -A
  git commit -m "fix: Correct LMR implementation for future use - bench 19191913"

  # Step 2: Create integration branch to preserve the work
  git checkout -b integration/lmr-with-move-ordering
  git push -u origin integration/lmr-with-move-ordering

  # Step 3: Document the branch (CRITICAL - see integration_branches.md)
  # Create documentation explaining:
  # - What's implemented
  # - What dependencies are needed
  # - The plan for completion

  # Step 4: Return to main and implement prerequisites
  git checkout main
  git feature history-heuristic  # Implement first dependency
  # ... implement and merge history heuristic

  git checkout main
  git feature killer-moves       # Implement second dependency
  # ... implement and merge killer moves

  # Step 5: Resume work on integration branch
  git checkout integration/lmr-with-move-ordering
  git rebase main  # Or merge main if there are conflicts

  # Step 6: Complete and enable the feature
  # Now LMR has access to move ordering
  # Enable the feature, test it, should work properly

  # Step 7: Merge to main when complete
  git checkout main
  git merge integration/lmr-with-move-ordering
  git push origin main

  # Step 8: Clean up
  git push origin --delete integration/lmr-with-move-ordering
  ```

  ### Integration Branch Management

  **Naming Convention:**
  - Use descriptive names: integration/lmr-with-move-ordering
  - Include the key dependency: integration/feature-with-prerequisite
  - No date prefix (these are long-lived)

  **Documentation Requirements:**
  - MUST create entry in project_docs/integration_branches.md
  - Document what's implemented and what's needed
  - Include completion plan and testing strategy
  - Update when dependencies are resolved

  **Lifecycle:**
  - Long-lived (weeks to months)
  - Periodically rebase/merge from main
  - Delete only after successful merge to main
  - Keep comprehensive documentation

  ### Professional Benefits

  1. **No Lost Work**: Implementation preserved and ready
  2. **Clean Main History**: Prerequisites merge in logical order
  3. **Clear Communication**: Anyone can understand the plan
  4. **Testable Components**: Each prerequisite tested independently
  5. **Industry Standard**: Used by major software companies

  ### Integration Branch Aliases

  Add these to your Git configuration:

  ```bash
  # Create integration branch (manual naming for clarity)
  git config --global alias.integration '!f() { git checkout -b integration/$1 && git push -u origin integration/$1; }; f'

  # List integration branches
  git config --global alias.list-integrations '!git branch -r | grep "origin/integration/"'

  # Show integration branch status
  git config --global alias.integration-status '!git for-each-ref --format="%(refname:short) %(committerdate:relative) %(subject)" refs/remotes/origin/integration/'
  ```

  ### Common Integration Scenarios

  **Feature Dependencies:**
  - LMR needs move ordering (history heuristic, killer moves)
  - Advanced evaluation needs endgame tables
  - Multi-threading needs thread-safe data structures

  **API Changes:**
  - New search feature needs UCI protocol updates
  - Evaluation changes need test suite updates
  - Performance optimization needs benchmarking infrastructure

  **Platform Support:**
  - SIMD optimizations need fallback implementations
  - GPU acceleration needs OpenCL infrastructure
  - Mobile support needs memory optimization

  This system will make your OpenBench testing much more organized and professional, with clear test names and easy branch management!
