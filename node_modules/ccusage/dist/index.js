#!/usr/bin/env node
import { BLOCKS_COMPACT_WIDTH_THRESHOLD, BLOCKS_DEFAULT_TERMINAL_WIDTH, BLOCKS_WARNING_THRESHOLD, BURN_RATE_THRESHOLDS, DEFAULT_RECENT_DAYS, DEFAULT_REFRESH_INTERVAL_SECONDS, MAX_REFRESH_INTERVAL_SECONDS, MCP_DEFAULT_PORT, MIN_REFRESH_INTERVAL_SECONDS, MIN_RENDER_INTERVAL_MS, PROJECT_ALIASES_ENV, PricingFetcher, WEEK_DAYS, __commonJSMin, __require, __toESM, isFailure, require_usingCtx, try_ } from "./pricing-fetcher-CTYPN13Y.js";
import { getTotalTokens } from "./_token-utils-WjkbrjKv.js";
import { CostModes, SortOrders, filterDateSchema, statuslineHookJsonSchema } from "./_types-C0oFKDO-.js";
import { calculateTotals, createTotalsObject } from "./calculate-cost-BDqO4yWA.js";
import { DEFAULT_SESSION_DURATION_HOURS, calculateBurnRate, calculateContextTokens, calculateCostForEntry, createUniqueHash, filterRecentBlocks, formatDateCompact, getClaudePaths, getContextUsageThresholds, getEarliestTimestamp, getUsageLimitResetTime, globUsageFiles, identifySessionBlocks, loadDailyUsageData, loadMonthlyUsageData, loadSessionBlockData, loadSessionData, loadSessionUsageById, loadWeeklyUsageData, projectBlockUsage, sortFilesByTimestamp, uniq, usageDataSchema } from "./data-loader-Plh5X-UR.js";
import { description, log, logger, name, version } from "./logger-dT_AJeHG.js";
import { detectMismatches, printMismatchReport } from "./debug-C4f2zPfQ.js";
import { createMcpHttpApp, createMcpServer, startMcpServerStdio } from "./mcp-DfY3l9w7.js";
import a, { readFile } from "node:fs/promises";
import path from "node:path";
import process$1 from "node:process";
import { stripVTControlCharacters } from "node:util";
import { fileURLToPath } from "node:url";
import { spawn } from "node:child_process";
import { on, once } from "node:events";
import { pipeline } from "node:stream/promises";
import * as readline from "node:readline/promises";
import { createServer } from "node:http";
import { Http2ServerRequest } from "node:http2";
import { Readable } from "node:stream";
import crypto from "node:crypto";
const DEFAULT_LOCALE = "en-US", BUILT_IN_PREFIX = "_", ARG_PREFIX = "arg", BUILT_IN_KEY_SEPARATOR = ":", ANONYMOUS_COMMAND_NAME = "(anonymous)", NOOP = () => {}, COMMON_ARGS = {
	help: {
		type: "boolean",
		short: "h",
		description: "Display this help message"
	},
	version: {
		type: "boolean",
		short: "v",
		description: "Display this version"
	}
}, COMMAND_OPTIONS_DEFAULT = {
	name: void 0,
	description: void 0,
	version: void 0,
	cwd: void 0,
	usageSilent: false,
	subCommands: void 0,
	leftMargin: 2,
	middleMargin: 10,
	usageOptionType: false,
	usageOptionValue: true,
	renderHeader: void 0,
	renderUsage: void 0,
	renderValidationErrors: void 0,
	translationAdapterFactory: void 0
};
function isLazyCommand(cmd) {
	return typeof cmd === "function" && "commandName" in cmd && !!cmd.commandName;
}
async function resolveLazyCommand(cmd, name$1, needRunResolving = false) {
	let command;
	if (isLazyCommand(cmd)) {
		if (command = Object.assign(create(), {
			name: cmd.commandName,
			description: cmd.description,
			args: cmd.args,
			examples: cmd.examples,
			resource: cmd.resource
		}), needRunResolving) {
			const loaded = await cmd();
			if (typeof loaded === "function") command.run = loaded;
			else if (typeof loaded === "object") {
				if (loaded.run == null) throw new TypeError(`'run' is required in command: ${cmd.name || name$1}`);
				command.run = loaded.run, command.name = loaded.name, command.description = loaded.description, command.args = loaded.args, command.examples = loaded.examples, command.resource = loaded.resource;
			} else throw new TypeError(`Cannot resolve command: ${cmd.name || name$1}`);
		}
	} else command = Object.assign(create(), cmd);
	if (command.name == null && name$1) command.name = name$1;
	return deepFreeze(command);
}
function resolveBuiltInKey(key) {
	return `${BUILT_IN_PREFIX}${BUILT_IN_KEY_SEPARATOR}${key}`;
}
function resolveArgKey(key) {
	return `${ARG_PREFIX}${BUILT_IN_KEY_SEPARATOR}${key}`;
}
async function resolveExamples(ctx, examples) {
	return typeof examples === "string" ? examples : typeof examples === "function" ? await examples(ctx) : "";
}
function mapResourceWithBuiltinKey(resource) {
	return Object.entries(resource).reduce((acc, [key, value]) => {
		return acc[resolveBuiltInKey(key)] = value, acc;
	}, create());
}
function create(obj = null) {
	return Object.create(obj);
}
function log$1(...args) {
	console.log(...args);
}
function deepFreeze(obj) {
	if (obj === null || typeof obj !== "object") return obj;
	for (const key of Object.keys(obj)) {
		const value = obj[key];
		if (typeof value === "object" && value !== null) deepFreeze(value);
	}
	return Object.freeze(obj);
}
var COMMAND = "COMMAND", COMMANDS = "COMMANDS", SUBCOMMAND = "SUBCOMMAND", USAGE = "USAGE", ARGUMENTS = "ARGUMENTS", OPTIONS = "OPTIONS", EXAMPLES = "EXAMPLES", FORMORE = "For more info, run any command with the `--help` flag:", NEGATABLE = "Negatable of", DEFAULT = "default", CHOICES = "choices", help = "Display this help message", version$1 = "Display this version", en_US_default = {
	COMMAND,
	COMMANDS,
	SUBCOMMAND,
	USAGE,
	ARGUMENTS,
	OPTIONS,
	EXAMPLES,
	FORMORE,
	NEGATABLE,
	DEFAULT,
	CHOICES,
	help,
	version: version$1
};
function createTranslationAdapter(options) {
	return new DefaultTranslation(options);
}
var DefaultTranslation = class {
	#resources = /* @__PURE__ */ new Map();
	#options;
	constructor(options) {
		if (this.#options = options, this.#resources.set(options.locale, create()), options.locale !== options.fallbackLocale) this.#resources.set(options.fallbackLocale, create());
	}
	getResource(locale) {
		return this.#resources.get(locale);
	}
	setResource(locale, resource) {
		this.#resources.set(locale, resource);
	}
	getMessage(locale, key) {
		const resource = this.getResource(locale);
		return resource ? resource[key] : void 0;
	}
	translate(locale, key, values = create()) {
		let message = this.getMessage(locale, key);
		if (message === void 0 && locale !== this.#options.fallbackLocale) message = this.getMessage(this.#options.fallbackLocale, key);
		if (message !== void 0) return message.replaceAll(/\{\{(\w+)\}\}/g, (_, name$1) => {
			return values[name$1] == null ? "" : values[name$1].toString();
		});
	}
};
const BUILT_IN_PREFIX_CODE = BUILT_IN_PREFIX.codePointAt(0);
async function createCommandContext({ args, values, positionals, rest, argv: argv$1, tokens, command, cliOptions, callMode = "entry", omitted = false }) {
	const _args = Object.entries(args).reduce((acc, [key, value]) => {
		return acc[key] = Object.assign(create(), value), acc;
	}, create()), env$2 = Object.assign(create(), COMMAND_OPTIONS_DEFAULT, cliOptions), locale = resolveLocale(cliOptions.locale), localeStr = locale.toString(), translationAdapterFactory = cliOptions.translationAdapterFactory || createTranslationAdapter, adapter = translationAdapterFactory({
		locale: localeStr,
		fallbackLocale: DEFAULT_LOCALE
	}), localeResources = /* @__PURE__ */ new Map();
	let builtInLoadedResources;
	if (localeResources.set(DEFAULT_LOCALE, mapResourceWithBuiltinKey(en_US_default)), DEFAULT_LOCALE !== localeStr) try {
		builtInLoadedResources = (await import(`./locales/${localeStr}.json`, { with: { type: "json" } })).default, localeResources.set(localeStr, mapResourceWithBuiltinKey(builtInLoadedResources));
	} catch {}
	function translate(key, values$1 = create()) {
		const strKey = key;
		if (strKey.codePointAt(0) === BUILT_IN_PREFIX_CODE) {
			const resource = localeResources.get(localeStr) || localeResources.get(DEFAULT_LOCALE);
			return resource[strKey] || strKey;
		} else return adapter.translate(locale.toString(), strKey, values$1) || "";
	}
	let cachedCommands;
	async function loadCommands() {
		if (cachedCommands) return cachedCommands;
		const subCommands$1 = [...cliOptions.subCommands || []];
		return cachedCommands = await Promise.all(subCommands$1.map(async ([name$1, cmd]) => await resolveLazyCommand(cmd, name$1)));
	}
	const ctx = deepFreeze(Object.assign(create(), {
		name: getCommandName(command),
		description: command.description,
		omitted,
		callMode,
		locale,
		env: env$2,
		args: _args,
		values,
		positionals,
		rest,
		_: argv$1,
		tokens,
		toKebab: command.toKebab,
		log: cliOptions.usageSilent ? NOOP : log$1,
		loadCommands,
		translate
	})), loadedOptionsResources = Object.entries(args).map(([key, arg]) => {
		const description$1 = arg.description || "";
		return [key, description$1];
	}), defaultCommandResource = loadedOptionsResources.reduce((res, [key, value]) => {
		return res[resolveArgKey(key)] = value, res;
	}, create());
	defaultCommandResource.description = command.description || "", defaultCommandResource.examples = await resolveExamples(ctx, command.examples), adapter.setResource(DEFAULT_LOCALE, defaultCommandResource);
	const originalResource = await loadCommandResource(ctx, command);
	if (originalResource) {
		const resource = Object.assign(create(), originalResource, { examples: await resolveExamples(ctx, originalResource.examples) });
		if (builtInLoadedResources) resource.help = builtInLoadedResources.help, resource.version = builtInLoadedResources.version;
		adapter.setResource(localeStr, resource);
	}
	return ctx;
}
function getCommandName(cmd) {
	return isLazyCommand(cmd) ? cmd.commandName || cmd.name || ANONYMOUS_COMMAND_NAME : typeof cmd === "object" && cmd.name || ANONYMOUS_COMMAND_NAME;
}
function resolveLocale(locale) {
	return locale instanceof Intl.Locale ? locale : typeof locale === "string" ? new Intl.Locale(locale) : new Intl.Locale(DEFAULT_LOCALE);
}
async function loadCommandResource(ctx, command) {
	let resource;
	try {
		resource = await command.resource?.(ctx);
	} catch {}
	return resource;
}
function define(definition) {
	return definition;
}
/**
* @author kazuya kawaguchi (a.k.a. kazupon)
* @license MIT
*/
function kebabnize(str) {
	return str.replace(/[A-Z]/g, (match, offset) => (offset > 0 ? "-" : "") + match.toLowerCase());
}
function renderHeader(ctx) {
	const title = ctx.env.description || ctx.env.name || "";
	return Promise.resolve(title ? `${title} (${ctx.env.name || ""}${ctx.env.version ? ` v${ctx.env.version}` : ""})` : title);
}
const COMMON_ARGS_KEYS = Object.keys(COMMON_ARGS);
async function renderUsage(ctx) {
	const messages$1 = [];
	if (!ctx.omitted) {
		const description$1 = resolveDescription(ctx);
		if (description$1) messages$1.push(description$1, "");
	}
	if (messages$1.push(...await renderUsageSection(ctx), ""), ctx.omitted && await hasCommands(ctx)) messages$1.push(...await renderCommandsSection(ctx), "");
	if (hasPositionalArgs(ctx)) messages$1.push(...await renderPositionalArgsSection(ctx), "");
	if (hasOptionalArgs(ctx)) messages$1.push(...await renderOptionalArgsSection(ctx), "");
	const examples = await renderExamplesSection(ctx);
	if (examples.length > 0) messages$1.push(...examples, "");
	return messages$1.join("\n");
}
async function renderPositionalArgsSection(ctx) {
	const messages$1 = [];
	return messages$1.push(`${ctx.translate(resolveBuiltInKey("ARGUMENTS"))}:`), messages$1.push(await generatePositionalArgsUsage(ctx)), messages$1;
}
async function renderOptionalArgsSection(ctx) {
	const messages$1 = [];
	return messages$1.push(`${ctx.translate(resolveBuiltInKey("OPTIONS"))}:`), messages$1.push(await generateOptionalArgsUsage(ctx, getOptionalArgsPairs(ctx))), messages$1;
}
async function renderExamplesSection(ctx) {
	const messages$1 = [], resolvedExamples = await resolveExamples$1(ctx);
	if (resolvedExamples) {
		const examples = resolvedExamples.split("\n").map((example) => example.padStart(ctx.env.leftMargin + example.length));
		messages$1.push(`${ctx.translate(resolveBuiltInKey("EXAMPLES"))}:`, ...examples);
	}
	return messages$1;
}
async function renderUsageSection(ctx) {
	const messages$1 = [`${ctx.translate(resolveBuiltInKey("USAGE"))}:`];
	if (ctx.omitted) {
		const defaultCommand = `${resolveEntry(ctx)}${await hasCommands(ctx) ? ` [${resolveSubCommand(ctx)}]` : ""} ${[generateOptionsSymbols(ctx), generatePositionalSymbols(ctx)].filter(Boolean).join(" ")}`;
		if (messages$1.push(defaultCommand.padStart(ctx.env.leftMargin + defaultCommand.length)), await hasCommands(ctx)) {
			const commandsUsage = `${resolveEntry(ctx)} <${ctx.translate(resolveBuiltInKey("COMMANDS"))}>`;
			messages$1.push(commandsUsage.padStart(ctx.env.leftMargin + commandsUsage.length));
		}
	} else {
		const usageStr = `${resolveEntry(ctx)} ${resolveSubCommand(ctx)} ${[generateOptionsSymbols(ctx), generatePositionalSymbols(ctx)].filter(Boolean).join(" ")}`;
		messages$1.push(usageStr.padStart(ctx.env.leftMargin + usageStr.length));
	}
	return messages$1;
}
async function renderCommandsSection(ctx) {
	const messages$1 = [`${ctx.translate(resolveBuiltInKey("COMMANDS"))}:`], loadedCommands = await ctx.loadCommands(), commandMaxLength = Math.max(...loadedCommands.map((cmd) => (cmd.name || "").length)), commandsStr = await Promise.all(loadedCommands.map((cmd) => {
		const key = cmd.name || "", desc = cmd.description || "", command = `${key.padEnd(commandMaxLength + ctx.env.middleMargin)}${desc} `;
		return `${command.padStart(ctx.env.leftMargin + command.length)} `;
	}));
	return messages$1.push(...commandsStr, "", ctx.translate(resolveBuiltInKey("FORMORE"))), messages$1.push(...loadedCommands.map((cmd) => {
		const commandHelp = `${ctx.env.name} ${cmd.name} --help`;
		return `${commandHelp.padStart(ctx.env.leftMargin + commandHelp.length)}`;
	})), messages$1;
}
function resolveEntry(ctx) {
	return ctx.env.name || ctx.translate(resolveBuiltInKey("COMMAND"));
}
function resolveSubCommand(ctx) {
	return ctx.name || ctx.translate(resolveBuiltInKey("SUBCOMMAND"));
}
function resolveDescription(ctx) {
	return ctx.translate("description") || ctx.description || "";
}
async function resolveExamples$1(ctx) {
	const ret = ctx.translate("examples");
	if (ret) return ret;
	const command = ctx.env.subCommands?.get(ctx.name || "");
	return await resolveExamples(ctx, command?.examples);
}
async function hasCommands(ctx) {
	const loadedCommands = await ctx.loadCommands();
	return loadedCommands.length > 1;
}
function hasOptionalArgs(ctx) {
	return !!(ctx.args && Object.values(ctx.args).some((arg) => arg.type !== "positional"));
}
function hasPositionalArgs(ctx) {
	return !!(ctx.args && Object.values(ctx.args).some((arg) => arg.type === "positional"));
}
function hasAllDefaultOptions(ctx) {
	return !!(ctx.args && Object.values(ctx.args).every((arg) => arg.default));
}
function generateOptionsSymbols(ctx) {
	return hasOptionalArgs(ctx) ? hasAllDefaultOptions(ctx) ? `[${ctx.translate(resolveBuiltInKey("OPTIONS"))}]` : `<${ctx.translate(resolveBuiltInKey("OPTIONS"))}>` : "";
}
function makeShortLongOptionPair(schema, name$1, toKebab) {
	const displayName = toKebab || schema.toKebab ? kebabnize(name$1) : name$1;
	let key = `--${displayName}`;
	if (schema.short) key = `-${schema.short}, ${key}`;
	return key;
}
function getOptionalArgsPairs(ctx) {
	return Object.entries(ctx.args).reduce((acc, [name$1, schema]) => {
		if (schema.type === "positional") return acc;
		let key = makeShortLongOptionPair(schema, name$1, ctx.toKebab);
		if (schema.type !== "boolean") {
			const displayName = ctx.toKebab || schema.toKebab ? kebabnize(name$1) : name$1;
			key = schema.default ? `${key} [${displayName}]` : `${key} <${displayName}>`;
		}
		if (acc[name$1] = key, schema.type === "boolean" && schema.negatable && !COMMON_ARGS_KEYS.includes(name$1)) {
			const displayName = ctx.toKebab || schema.toKebab ? kebabnize(name$1) : name$1;
			acc[`no-${name$1}`] = `--no-${displayName}`;
		}
		return acc;
	}, create());
}
const resolveNegatableKey = (key) => key.split("no-")[1];
function resolveNegatableType(key, ctx) {
	return ctx.args[key.startsWith("no-") ? resolveNegatableKey(key) : key].type;
}
function generateDefaultDisplayValue(ctx, schema) {
	return `${ctx.translate(resolveBuiltInKey("DEFAULT"))}: ${schema.default}`;
}
function resolveDisplayValue(ctx, key) {
	if (COMMON_ARGS_KEYS.includes(key)) return "";
	const schema = ctx.args[key];
	if ((schema.type === "boolean" || schema.type === "number" || schema.type === "string" || schema.type === "custom") && schema.default !== void 0) return `(${generateDefaultDisplayValue(ctx, schema)})`;
	if (schema.type === "enum") {
		const _default = schema.default !== void 0 ? generateDefaultDisplayValue(ctx, schema) : "", choices = `${ctx.translate(resolveBuiltInKey("CHOICES"))}: ${schema.choices.join(" | ")}`;
		return `(${_default ? `${_default}, ${choices}` : choices})`;
	}
	return "";
}
async function generateOptionalArgsUsage(ctx, optionsPairs) {
	const optionsMaxLength = Math.max(...Object.entries(optionsPairs).map(([_, value]) => value.length)), optionSchemaMaxLength = ctx.env.usageOptionType ? Math.max(...Object.entries(optionsPairs).map(([key]) => resolveNegatableType(key, ctx).length)) : 0, usages = await Promise.all(Object.entries(optionsPairs).map(([key, value]) => {
		let rawDesc = ctx.translate(resolveArgKey(key));
		if (!rawDesc && key.startsWith("no-")) {
			const name$1 = resolveNegatableKey(key), schema = ctx.args[name$1], optionKey = makeShortLongOptionPair(schema, name$1, ctx.toKebab);
			rawDesc = `${ctx.translate(resolveBuiltInKey("NEGATABLE"))} ${optionKey}`;
		}
		const optionsSchema = ctx.env.usageOptionType ? `[${resolveNegatableType(key, ctx)}] ` : "", valueDesc = key.startsWith("no-") ? "" : resolveDisplayValue(ctx, key), desc = `${optionsSchema ? optionsSchema.padEnd(optionSchemaMaxLength + 3) : ""}${rawDesc}`, option = `${value.padEnd(optionsMaxLength + ctx.env.middleMargin)}${desc}${valueDesc ? ` ${valueDesc}` : ""}`;
		return `${option.padStart(ctx.env.leftMargin + option.length)}`;
	}));
	return usages.join("\n");
}
function getPositionalArgs(ctx) {
	return Object.entries(ctx.args).filter(([_, schema]) => schema.type === "positional");
}
async function generatePositionalArgsUsage(ctx) {
	const positionals = getPositionalArgs(ctx), argsMaxLength = Math.max(...positionals.map(([name$1]) => name$1.length)), usages = await Promise.all(positionals.map(([name$1]) => {
		const desc = ctx.translate(resolveArgKey(name$1)) || ctx.args[name$1].description || "", arg = `${name$1.padEnd(argsMaxLength + ctx.env.middleMargin)} ${desc}`;
		return `${arg.padStart(ctx.env.leftMargin + arg.length)}`;
	}));
	return usages.join("\n");
}
function generatePositionalSymbols(ctx) {
	return hasPositionalArgs(ctx) ? getPositionalArgs(ctx).map(([name$1]) => `<${name$1}>`).join(" ") : "";
}
function renderValidationErrors(_ctx, error) {
	const messages$1 = [];
	for (const err of error.errors) messages$1.push(err.message);
	return Promise.resolve(messages$1.join("\n"));
}
const HYPHEN_CHAR = "-", HYPHEN_CODE = HYPHEN_CHAR.codePointAt(0), EQUAL_CHAR = "=", EQUAL_CODE = EQUAL_CHAR.codePointAt(0), TERMINATOR = "--", SHORT_OPTION_PREFIX = HYPHEN_CHAR, LONG_OPTION_PREFIX = "--";
function parseArgs(args, options = {}) {
	const { allowCompatible = false } = options, tokens = [], remainings = [...args];
	let index = -1, groupCount = 0, hasShortValueSeparator = false;
	while (remainings.length > 0) {
		const arg = remainings.shift();
		if (arg == void 0) break;
		const nextArg = remainings[0];
		if (groupCount > 0) groupCount--;
		else index++;
		if (arg === TERMINATOR) {
			tokens.push({
				kind: "option-terminator",
				index
			});
			const mapped = remainings.map((arg$1) => {
				return {
					kind: "positional",
					index: ++index,
					value: arg$1
				};
			});
			tokens.push(...mapped);
			break;
		}
		if (isShortOption(arg)) {
			const shortOption = arg.charAt(1);
			let value, inlineValue;
			if (groupCount) {
				if (tokens.push({
					kind: "option",
					name: shortOption,
					rawName: arg,
					index,
					value,
					inlineValue
				}), groupCount === 1 && hasOptionValue(nextArg)) {
					if (value = remainings.shift(), hasShortValueSeparator) inlineValue = true, hasShortValueSeparator = false;
					tokens.push({
						kind: "option",
						index,
						value,
						inlineValue
					});
				}
			} else tokens.push({
				kind: "option",
				name: shortOption,
				rawName: arg,
				index,
				value,
				inlineValue
			});
			if (value != null) ++index;
			continue;
		}
		if (isShortOptionGroup(arg)) {
			const expanded = [];
			let shortValue = "";
			for (let i = 1; i < arg.length; i++) {
				const shortableOption = arg.charAt(i);
				if (hasShortValueSeparator) shortValue += shortableOption;
				else if (!allowCompatible && shortableOption.codePointAt(0) === EQUAL_CODE) hasShortValueSeparator = true;
				else expanded.push(`${SHORT_OPTION_PREFIX}${shortableOption}`);
			}
			if (shortValue) expanded.push(shortValue);
			remainings.unshift(...expanded), groupCount = expanded.length;
			continue;
		}
		if (isLongOption(arg)) {
			const longOption = arg.slice(2);
			tokens.push({
				kind: "option",
				name: longOption,
				rawName: arg,
				index,
				value: void 0,
				inlineValue: void 0
			});
			continue;
		}
		if (isLongOptionAndValue(arg)) {
			const equalIndex = arg.indexOf(EQUAL_CHAR), longOption = arg.slice(2, equalIndex), value = arg.slice(equalIndex + 1);
			tokens.push({
				kind: "option",
				name: longOption,
				rawName: `${LONG_OPTION_PREFIX}${longOption}`,
				index,
				value,
				inlineValue: true
			});
			continue;
		}
		tokens.push({
			kind: "positional",
			index,
			value: arg
		});
	}
	return tokens;
}
function isShortOption(arg) {
	return arg.length === 2 && arg.codePointAt(0) === HYPHEN_CODE && arg.codePointAt(1) !== HYPHEN_CODE;
}
function isShortOptionGroup(arg) {
	return !(arg.length <= 2 || arg.codePointAt(0) !== HYPHEN_CODE || arg.codePointAt(1) === HYPHEN_CODE);
}
function isLongOption(arg) {
	return hasLongOptionPrefix(arg) && !arg.includes(EQUAL_CHAR, 3);
}
function isLongOptionAndValue(arg) {
	return hasLongOptionPrefix(arg) && arg.includes(EQUAL_CHAR, 3);
}
function hasLongOptionPrefix(arg) {
	return arg.length > 2 && ~arg.indexOf(LONG_OPTION_PREFIX);
}
function hasOptionValue(value) {
	return !(value == null) && value.codePointAt(0) !== HYPHEN_CODE;
}
const SKIP_POSITIONAL_DEFAULT = -1;
function resolveArgs(args, tokens, { shortGrouping = false, skipPositional = SKIP_POSITIONAL_DEFAULT, toKebab = false } = {}) {
	const skipPositionalIndex = typeof skipPositional === "number" ? Math.max(skipPositional, SKIP_POSITIONAL_DEFAULT) : SKIP_POSITIONAL_DEFAULT, rest = [], optionTokens = [], positionalTokens = [];
	let currentLongOption, currentShortOption;
	const expandableShortOptions = [];
	function toShortValue() {
		if (expandableShortOptions.length === 0) return void 0;
		{
			const value = expandableShortOptions.map((token) => token.name).join("");
			return expandableShortOptions.length = 0, value;
		}
	}
	function applyLongOptionValue(value = void 0) {
		if (currentLongOption) currentLongOption.value = value, optionTokens.push({ ...currentLongOption }), currentLongOption = void 0;
	}
	function applyShortOptionValue(value = void 0) {
		if (currentShortOption) currentShortOption.value = value || toShortValue(), optionTokens.push({ ...currentShortOption }), currentShortOption = void 0;
	}
	const schemas = Object.values(args);
	let terminated = false;
	for (let i = 0; i < tokens.length; i++) {
		const token = tokens[i];
		if (token.kind === "positional") {
			if (terminated && token.value) {
				rest.push(token.value);
				continue;
			}
			if (currentShortOption) {
				const found = schemas.find((schema) => schema.short === currentShortOption.name && schema.type === "boolean");
				if (found) positionalTokens.push({ ...token });
			} else if (currentLongOption) {
				const found = args[currentLongOption.name]?.type === "boolean";
				if (found) positionalTokens.push({ ...token });
			} else positionalTokens.push({ ...token });
			applyLongOptionValue(token.value), applyShortOptionValue(token.value);
		} else if (token.kind === "option") if (token.rawName) {
			if (hasLongOptionPrefix(token.rawName)) {
				if (applyLongOptionValue(), token.inlineValue) optionTokens.push({ ...token });
				else currentLongOption = { ...token };
				applyShortOptionValue();
			} else if (isShortOption(token.rawName)) if (currentShortOption) {
				if (currentShortOption.index === token.index) if (shortGrouping) currentShortOption.value = token.value, optionTokens.push({ ...currentShortOption }), currentShortOption = { ...token };
				else expandableShortOptions.push({ ...token });
				else currentShortOption.value = toShortValue(), optionTokens.push({ ...currentShortOption }), currentShortOption = { ...token };
				applyLongOptionValue();
			} else currentShortOption = { ...token }, applyLongOptionValue();
		} else {
			if (currentShortOption && currentShortOption.index == token.index && token.inlineValue) currentShortOption.value = token.value, optionTokens.push({ ...currentShortOption }), currentShortOption = void 0;
			applyLongOptionValue();
		}
		else {
			if (token.kind === "option-terminator") terminated = true;
			applyLongOptionValue(), applyShortOptionValue();
		}
	}
	applyLongOptionValue(), applyShortOptionValue();
	const values = Object.create(null), errors = [];
	function checkTokenName(option, schema, token) {
		return token.name === (schema.type === "boolean" ? schema.negatable && token.name?.startsWith("no-") ? `no-${option}` : option : option);
	}
	const positionalItemCount = tokens.filter((token) => token.kind === "positional").length;
	function getPositionalSkipIndex() {
		return Math.min(skipPositionalIndex, positionalItemCount);
	}
	let positionalsCount = 0;
	for (const [rawArg, schema] of Object.entries(args)) {
		const arg = toKebab || schema.toKebab ? kebabnize(rawArg) : rawArg;
		if (schema.required) {
			const found = optionTokens.find((token) => {
				return schema.short && token.name === schema.short || token.rawName && hasLongOptionPrefix(token.rawName) && token.name === arg;
			});
			if (!found) {
				errors.push(createRequireError(arg, schema));
				continue;
			}
		}
		if (schema.type === "positional") {
			if (skipPositionalIndex > SKIP_POSITIONAL_DEFAULT) while (positionalsCount <= getPositionalSkipIndex()) positionalsCount++;
			const positional = positionalTokens[positionalsCount];
			if (positional != null) values[rawArg] = positional.value;
			else errors.push(createRequireError(arg, schema));
			positionalsCount++;
			continue;
		}
		for (let i = 0; i < optionTokens.length; i++) {
			const token = optionTokens[i];
			if (checkTokenName(arg, schema, token) && token.rawName != void 0 && hasLongOptionPrefix(token.rawName) || schema.short === token.name && token.rawName != void 0 && isShortOption(token.rawName)) {
				const invalid = validateRequire(token, arg, schema);
				if (invalid) {
					errors.push(invalid);
					continue;
				}
				if (schema.type === "boolean") token.value = void 0;
				const [parsedValue, error] = parse(token, arg, schema);
				if (error) errors.push(error);
				else if (schema.multiple) values[rawArg] ||= [], values[rawArg].push(parsedValue);
				else values[rawArg] = parsedValue;
			}
		}
		if (values[rawArg] == null && schema.default != null) values[rawArg] = schema.default;
	}
	return {
		values,
		positionals: positionalTokens.map((token) => token.value),
		rest,
		error: errors.length > 0 ? new AggregateError(errors) : void 0
	};
}
function parse(token, option, schema) {
	switch (schema.type) {
		case "string": return typeof token.value === "string" ? [token.value || schema.default, void 0] : [void 0, createTypeError(option, schema)];
		case "boolean": return token.value ? [token.value || schema.default, void 0] : [!(schema.negatable && token.name.startsWith("no-")), void 0];
		case "number": return isNumeric(token.value) ? token.value ? [+token.value, void 0] : [+(schema.default || ""), void 0] : [void 0, createTypeError(option, schema)];
		case "enum": return schema.choices && !schema.choices.includes(token.value) ? [void 0, new ArgResolveError(`Optional argument '--${option}' ${schema.short ? `or '-${schema.short}' ` : ""}should be chosen from '${schema.type}' [${schema.choices.map((c) => JSON.stringify(c)).join(", ")}] values`, option, "type", schema)] : [token.value || schema.default, void 0];
		case "custom":
			if (typeof schema.parse !== "function") throw new TypeError(`argument '${option}' should have a 'parse' function`);
			try {
				return [schema.parse(token.value || String(schema.default || "")), void 0];
			} catch (error) {
				return [void 0, error];
			}
		default: throw new Error(`Unsupported argument type '${schema.type}' for option '${option}'`);
	}
}
function createRequireError(option, schema) {
	const message = schema.type === "positional" ? `Positional argument '${option}' is required` : `Optional argument '--${option}' ${schema.short ? `or '-${schema.short}' ` : ""}is required`;
	return new ArgResolveError(message, option, "required", schema);
}
var ArgResolveError = class extends Error {
	name;
	schema;
	type;
	constructor(message, name$1, type, schema) {
		super(message), this.name = name$1, this.type = type, this.schema = schema;
	}
};
function validateRequire(token, option, schema) {
	if (schema.required && schema.type !== "boolean" && !token.value) return createRequireError(option, schema);
}
function isNumeric(str) {
	return str.trim() !== "" && !isNaN(str);
}
function createTypeError(option, schema) {
	return new ArgResolveError(`Optional argument '--${option}' ${schema.short ? `or '-${schema.short}' ` : ""}should be '${schema.type}'`, option, "type", schema);
}
async function cli(argv$1, entry, options = {}) {
	const cliOptions = resolveCliOptions(options, entry), tokens = parseArgs(argv$1), subCommand = getSubCommand(tokens), { commandName: name$1, command, callMode } = await resolveCommand(subCommand, entry, cliOptions);
	if (!command) throw new Error(`Command not found: ${name$1 || ""}`);
	const args = resolveArguments(getCommandArgs(command)), { values, positionals, rest, error } = resolveArgs(args, tokens, {
		shortGrouping: true,
		toKebab: command.toKebab,
		skipPositional: cliOptions.subCommands.size > 0 ? 0 : -1
	}), omitted = !subCommand, ctx = await createCommandContext({
		args,
		values,
		positionals,
		rest,
		argv: argv$1,
		tokens,
		omitted,
		callMode,
		command,
		cliOptions
	});
	if (values.version) {
		showVersion(ctx);
		return;
	}
	const usageBuffer = [], header = await showHeader(ctx);
	if (header) usageBuffer.push(header);
	if (values.help) {
		const usage = await showUsage(ctx);
		if (usage) usageBuffer.push(usage);
		return usageBuffer.join("\n");
	}
	if (error) {
		await showValidationErrors(ctx, error);
		return;
	}
	await executeCommand(command, ctx, name$1 || "");
}
function getCommandArgs(cmd) {
	return isLazyCommand(cmd) ? cmd.args || create() : typeof cmd === "object" && cmd.args || create();
}
function resolveArguments(args) {
	return Object.assign(create(), args, COMMON_ARGS);
}
function resolveCliOptions(options, entry) {
	const subCommands$1 = new Map(options.subCommands);
	if (options.subCommands) {
		if (isLazyCommand(entry)) subCommands$1.set(entry.commandName, entry);
		else if (typeof entry === "object" && entry.name) subCommands$1.set(entry.name, entry);
	}
	const resolvedOptions = Object.assign(create(), COMMAND_OPTIONS_DEFAULT, options, { subCommands: subCommands$1 });
	return resolvedOptions;
}
function getSubCommand(tokens) {
	const firstToken = tokens[0];
	return firstToken && firstToken.kind === "positional" && firstToken.index === 0 && firstToken.value ? firstToken.value : "";
}
async function showUsage(ctx) {
	if (ctx.env.renderUsage === null) return;
	const usage = await (ctx.env.renderUsage || renderUsage)(ctx);
	if (usage) return ctx.log(usage), usage;
}
function showVersion(ctx) {
	ctx.log(ctx.env.version);
}
async function showHeader(ctx) {
	if (ctx.env.renderHeader === null) return;
	const header = await (ctx.env.renderHeader || renderHeader)(ctx);
	if (header) return ctx.log(header), ctx.log(), header;
}
async function showValidationErrors(ctx, error) {
	if (ctx.env.renderValidationErrors === null) return;
	const render = ctx.env.renderValidationErrors || renderValidationErrors;
	ctx.log(await render(ctx, error));
}
const CANNOT_RESOLVE_COMMAND = { callMode: "unexpected" };
async function resolveCommand(sub, entry, options) {
	const omitted = !sub;
	async function doResolveCommand() {
		if (typeof entry === "function") if ("commandName" in entry && entry.commandName) return {
			commandName: entry.commandName,
			command: entry,
			callMode: "entry"
		};
		else return {
			command: { run: entry },
			callMode: "entry"
		};
		else if (typeof entry === "object") return {
			commandName: resolveEntryName(entry),
			command: entry,
			callMode: "entry"
		};
		else return CANNOT_RESOLVE_COMMAND;
	}
	if (omitted || options.subCommands?.size === 0) return doResolveCommand();
	const cmd = options.subCommands?.get(sub);
	if (cmd == null) return {
		commandName: sub,
		callMode: "unexpected"
	};
	if (isLazyCommand(cmd) && cmd.commandName == null) cmd.commandName = sub;
	else if (typeof cmd === "object" && cmd.name == null) cmd.name = sub;
	return {
		commandName: sub,
		command: cmd,
		callMode: "subCommand"
	};
}
function resolveEntryName(entry) {
	return entry.name || ANONYMOUS_COMMAND_NAME;
}
async function executeCommand(cmd, ctx, name$1) {
	const resolved = isLazyCommand(cmd) ? await resolveLazyCommand(cmd, name$1, true) : cmd;
	if (resolved.run == null) throw new Error(`'run' not found on Command \`${name$1}\``);
	await resolved.run(ctx);
}
var require_picocolors = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	let p = process || {}, argv = p.argv || [], env$1 = p.env || {}, isColorSupported = !(!!env$1.NO_COLOR || argv.includes("--no-color")) && (!!env$1.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env$1.TERM !== "dumb" || !!env$1.CI), formatter = (open, close, replace = open) => (input) => {
		let string = "" + input, index = string.indexOf(close, open.length);
		return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
	}, replaceClose = (string, close, replace, index) => {
		let result = "", cursor = 0;
		do
			result += string.substring(cursor, index) + replace, cursor = index + close.length, index = string.indexOf(close, cursor);
		while (~index);
		return result + string.substring(cursor);
	}, createColors = (enabled = isColorSupported) => {
		let f = enabled ? formatter : () => String;
		return {
			isColorSupported: enabled,
			reset: f("\x1B[0m", "\x1B[0m"),
			bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
			dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
			italic: f("\x1B[3m", "\x1B[23m"),
			underline: f("\x1B[4m", "\x1B[24m"),
			inverse: f("\x1B[7m", "\x1B[27m"),
			hidden: f("\x1B[8m", "\x1B[28m"),
			strikethrough: f("\x1B[9m", "\x1B[29m"),
			black: f("\x1B[30m", "\x1B[39m"),
			red: f("\x1B[31m", "\x1B[39m"),
			green: f("\x1B[32m", "\x1B[39m"),
			yellow: f("\x1B[33m", "\x1B[39m"),
			blue: f("\x1B[34m", "\x1B[39m"),
			magenta: f("\x1B[35m", "\x1B[39m"),
			cyan: f("\x1B[36m", "\x1B[39m"),
			white: f("\x1B[37m", "\x1B[39m"),
			gray: f("\x1B[90m", "\x1B[39m"),
			bgBlack: f("\x1B[40m", "\x1B[49m"),
			bgRed: f("\x1B[41m", "\x1B[49m"),
			bgGreen: f("\x1B[42m", "\x1B[49m"),
			bgYellow: f("\x1B[43m", "\x1B[49m"),
			bgBlue: f("\x1B[44m", "\x1B[49m"),
			bgMagenta: f("\x1B[45m", "\x1B[49m"),
			bgCyan: f("\x1B[46m", "\x1B[49m"),
			bgWhite: f("\x1B[47m", "\x1B[49m"),
			blackBright: f("\x1B[90m", "\x1B[39m"),
			redBright: f("\x1B[91m", "\x1B[39m"),
			greenBright: f("\x1B[92m", "\x1B[39m"),
			yellowBright: f("\x1B[93m", "\x1B[39m"),
			blueBright: f("\x1B[94m", "\x1B[39m"),
			magentaBright: f("\x1B[95m", "\x1B[39m"),
			cyanBright: f("\x1B[96m", "\x1B[39m"),
			whiteBright: f("\x1B[97m", "\x1B[39m"),
			bgBlackBright: f("\x1B[100m", "\x1B[49m"),
			bgRedBright: f("\x1B[101m", "\x1B[49m"),
			bgGreenBright: f("\x1B[102m", "\x1B[49m"),
			bgYellowBright: f("\x1B[103m", "\x1B[49m"),
			bgBlueBright: f("\x1B[104m", "\x1B[49m"),
			bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
			bgCyanBright: f("\x1B[106m", "\x1B[49m"),
			bgWhiteBright: f("\x1B[107m", "\x1B[49m")
		};
	};
	module.exports = createColors(), module.exports.createColors = createColors;
})), import_picocolors$8 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
const getContext = (raw) => ({
	start: process$1.hrtime.bigint(),
	command: raw.map((part) => getCommandPart(stripVTControlCharacters(part))).join(" "),
	state: {
		stdout: "",
		stderr: "",
		output: ""
	}
}), getCommandPart = (part) => /[^\w./-]/.test(part) ? `'${part.replaceAll("'", "'\\''")}'` : part, getOptions = ({ stdin: stdin$2, stdout: stdout$1, stderr, stdio = [
	stdin$2,
	stdout$1,
	stderr
], env: envOption, preferLocal, cwd: cwdOption = ".",...options }) => {
	const cwd = cwdOption instanceof URL ? fileURLToPath(cwdOption) : path.resolve(cwdOption), env$2 = envOption ? {
		...process$1.env,
		...envOption
	} : void 0, input = stdio[0]?.string;
	return {
		...options,
		input,
		stdio: input === void 0 ? stdio : ["pipe", ...stdio.slice(1)],
		env: preferLocal ? addLocalPath(env$2 ?? process$1.env, cwd) : env$2,
		cwd
	};
}, addLocalPath = ({ Path = "", PATH = Path,...env$2 }, cwd) => {
	const pathParts = PATH.split(path.delimiter), localPaths = getLocalPaths([], path.resolve(cwd)).map((localPath) => path.join(localPath, "node_modules/.bin")).filter((localPath) => !pathParts.includes(localPath));
	return {
		...env$2,
		PATH: [...localPaths, PATH].filter(Boolean).join(path.delimiter)
	};
}, getLocalPaths = (localPaths, localPath) => localPaths.at(-1) === localPath ? localPaths : getLocalPaths([...localPaths, localPath], path.resolve(localPath, "..")), applyForceShell = async (file, commandArguments, options) => await shouldForceShell(file, options) ? [
	escapeFile(file),
	commandArguments.map((argument) => escapeArgument(argument)),
	{
		...options,
		shell: true
	}
] : [
	file,
	commandArguments,
	options
], shouldForceShell = async (file, { shell, cwd, env: env$2 = process$1.env }) => process$1.platform === "win32" && !shell && !await isExe(file, cwd, env$2), isExe = (file, cwd, { Path = "", PATH = Path }) => exeExtensions.some((extension) => file.toLowerCase().endsWith(extension)) || mIsExe(file, cwd, PATH), EXE_MEMO = {}, memoize = (function_) => (...arguments_) => EXE_MEMO[arguments_.join("\0")] ??= function_(...arguments_), access = memoize(a.access), mIsExe = memoize(async (file, cwd, PATH) => {
	const parts = PATH.split(path.delimiter).filter(Boolean).map((part) => part.replace(/^"(.*)"$/, "$1"));
	try {
		await Promise.any([cwd, ...parts].flatMap((part) => exeExtensions.map((extension) => access(`${path.resolve(part, file)}${extension}`))));
	} catch {
		return false;
	}
	return true;
}), exeExtensions = [".exe", ".com"], escapeArgument = (argument) => escapeFile(escapeFile(`"${argument.replaceAll(/(\\*)"/g, "$1$1\\\"").replace(/(\\*)$/, "$1$1")}"`)), escapeFile = (file) => file.replaceAll(/([()\][%!^"`<>&|;, *?])/g, "^$1"), getResult = async (nodeChildProcess, { input }, context) => {
	const instance = await nodeChildProcess;
	if (input !== void 0) instance.stdin.end(input);
	const onClose = once(instance, "close");
	try {
		return await Promise.race([onClose, ...instance.stdio.filter(Boolean).map((stream) => onStreamError(stream))]), checkFailure(context, getErrorOutput(instance)), getOutputs(context);
	} catch (error) {
		throw await Promise.allSettled([onClose]), getResultError(error, instance, context);
	}
}, onStreamError = async (stream) => {
	for await (const [error] of on(stream, "error")) if (!["ERR_STREAM_PREMATURE_CLOSE", "EPIPE"].includes(error?.code)) throw error;
}, checkFailure = ({ command }, { exitCode, signalName }) => {
	if (signalName !== void 0) throw new SubprocessError(`Command was terminated with ${signalName}: ${command}`);
	if (exitCode !== void 0) throw new SubprocessError(`Command failed with exit code ${exitCode}: ${command}`);
}, getResultError = (error, instance, context) => Object.assign(getErrorInstance(error, context), getErrorOutput(instance), getOutputs(context)), getErrorInstance = (error, { command }) => error instanceof SubprocessError ? error : new SubprocessError(`Command failed: ${command}`, { cause: error });
var SubprocessError = class extends Error {
	name = "SubprocessError";
};
const getErrorOutput = ({ exitCode, signalCode }) => ({
	...exitCode < 1 ? {} : { exitCode },
	...signalCode === null ? {} : { signalName: signalCode }
}), getOutputs = ({ state: { stdout: stdout$1, stderr, output }, command, start }) => ({
	stdout: getOutput(stdout$1),
	stderr: getOutput(stderr),
	output: getOutput(output),
	command,
	durationMs: Number(process$1.hrtime.bigint() - start) / 1e6
}), getOutput = (output) => output.at(-1) === "\n" ? output.slice(0, output.at(-2) === "\r" ? -2 : -1) : output, spawnSubprocess = async (file, commandArguments, options, context) => {
	try {
		if (["node", "node.exe"].includes(file.toLowerCase())) file = process$1.execPath, commandArguments = [...process$1.execArgv.filter((flag) => !flag.startsWith("--inspect")), ...commandArguments];
		[file, commandArguments, options] = await applyForceShell(file, commandArguments, options), [file, commandArguments, options] = concatenateShell(file, commandArguments, options);
		const instance = spawn(file, commandArguments, options);
		return bufferOutput(instance.stdout, context, "stdout"), bufferOutput(instance.stderr, context, "stderr"), instance.once("error", () => {}), await once(instance, "spawn"), instance;
	} catch (error) {
		throw getResultError(error, {}, context);
	}
}, concatenateShell = (file, commandArguments, options) => options.shell && commandArguments.length > 0 ? [
	[file, ...commandArguments].join(" "),
	[],
	options
] : [
	file,
	commandArguments,
	options
], bufferOutput = (stream, { state }, streamName) => {
	if (stream) {
		if (stream.setEncoding("utf8"), !state.isIterating) state.isIterating = false, stream.on("data", (chunk) => {
			state[streamName] += chunk, state.output += chunk;
		});
	}
}, handlePipe = async (subprocesses) => {
	const [[from, to]] = await Promise.all([Promise.allSettled(subprocesses), pipeStreams(subprocesses)]);
	if (to.reason) throw to.reason.pipedFrom = from.reason ?? from.value, to.reason;
	if (from.reason) throw from.reason;
	return {
		...to.value,
		pipedFrom: from.value
	};
}, pipeStreams = async (subprocesses) => {
	try {
		const [{ stdout: stdout$1 }, { stdin: stdin$2 }] = await Promise.all(subprocesses.map(({ nodeChildProcess }) => nodeChildProcess));
		if (stdin$2 === null) throw new Error("The \"stdin\" option must be set on the first \"spawn()\" call in the pipeline.");
		if (stdout$1 === null) throw new Error("The \"stdout\" option must be set on the last \"spawn()\" call in the pipeline.");
		pipeline(stdout$1, stdin$2).catch(() => {});
	} catch (error) {
		throw await Promise.allSettled(subprocesses.map(({ nodeChildProcess }) => closeStdin(nodeChildProcess))), error;
	}
}, closeStdin = async (nodeChildProcess) => {
	const { stdin: stdin$2 } = await nodeChildProcess;
	stdin$2.end();
}, lineIterator = async function* (subprocess, { state }, streamName) {
	if (state.isIterating === false) throw new Error(`The subprocess must be iterated right away, for example:
	for await (const line of spawn(...)) { ... }`);
	state.isIterating = true;
	try {
		const { [streamName]: stream } = await subprocess.nodeChildProcess;
		if (!stream) return;
		yield* readline.createInterface({ input: stream });
	} finally {
		await subprocess;
	}
}, combineAsyncIterators = async function* (...iterators) {
	try {
		let promises = [];
		while (iterators.length > 0) {
			promises = iterators.map((iterator$1, index$1) => promises[index$1] ?? getNext(iterator$1));
			const [{ value, done }, index] = await Promise.race(promises.map((promise, index$1) => Promise.all([promise, index$1]))), [iterator] = iterators.splice(index, 1);
			if (promises.splice(index, 1), !done) iterators.push(iterator), yield value;
		}
	} finally {
		await Promise.all(iterators.map((iterator) => iterator.return()));
	}
}, getNext = async (iterator) => {
	try {
		return await iterator.next();
	} catch (error) {
		await iterator.throw(error);
	}
};
function spawn$1(file, second, third, previous) {
	const [commandArguments = [], options = {}] = Array.isArray(second) ? [second, third] : [[], second], context = getContext([file, ...commandArguments]), spawnOptions = getOptions(options), nodeChildProcess = spawnSubprocess(file, commandArguments, spawnOptions, context);
	let subprocess = getResult(nodeChildProcess, spawnOptions, context);
	Object.assign(subprocess, { nodeChildProcess }), subprocess = previous ? handlePipe([previous, subprocess]) : subprocess;
	const stdout$1 = lineIterator(subprocess, context, "stdout"), stderr = lineIterator(subprocess, context, "stderr");
	return Object.assign(subprocess, {
		nodeChildProcess,
		stdout: stdout$1,
		stderr,
		[Symbol.asyncIterator]: () => combineAsyncIterators(stdout$1, stderr),
		pipe: (file$1, second$1, third$1) => spawn$1(file$1, second$1, third$1, subprocess)
	});
}
async function processWithJq(jsonData, jqCommand) {
	const jsonString = JSON.stringify(jsonData), result = try_({
		try: async () => {
			const spawnResult = await spawn$1("jq", [jqCommand], { stdin: { string: jsonString } });
			return spawnResult.output.trim();
		},
		catch: (error) => {
			return error instanceof Error ? error.message.includes("ENOENT") || error.message.includes("not found") ? /* @__PURE__ */ new Error("jq command not found. Please install jq to use the --jq option.") : /* @__PURE__ */ new Error(`jq processing failed: ${error.message}`) : /* @__PURE__ */ new Error("Unknown error during jq processing");
		}
	});
	return result();
}
function parseDateArg(value) {
	const result = filterDateSchema.safeParse(value);
	if (!result.success) throw new TypeError(result.error.issues[0]?.message ?? "Invalid date format");
	return result.data;
}
const sharedArgs = {
	since: {
		type: "custom",
		short: "s",
		description: "Filter from date (YYYYMMDD format)",
		parse: parseDateArg
	},
	until: {
		type: "custom",
		short: "u",
		description: "Filter until date (YYYYMMDD format)",
		parse: parseDateArg
	},
	json: {
		type: "boolean",
		short: "j",
		description: "Output in JSON format",
		default: false
	},
	mode: {
		type: "enum",
		short: "m",
		description: "Cost calculation mode: auto (use costUSD if exists, otherwise calculate), calculate (always calculate), display (always use costUSD)",
		default: "auto",
		choices: CostModes
	},
	debug: {
		type: "boolean",
		short: "d",
		description: "Show pricing mismatch information for debugging",
		default: false
	},
	debugSamples: {
		type: "number",
		description: "Number of sample discrepancies to show in debug output (default: 5)",
		default: 5
	},
	order: {
		type: "enum",
		short: "o",
		description: "Sort order: desc (newest first) or asc (oldest first)",
		default: "asc",
		choices: SortOrders
	},
	breakdown: {
		type: "boolean",
		short: "b",
		description: "Show per-model cost breakdown",
		default: false
	},
	offline: {
		type: "boolean",
		negatable: true,
		short: "O",
		description: "Use cached pricing data for Claude models instead of fetching from API",
		default: false
	},
	color: {
		type: "boolean",
		description: "Enable colored output (default: auto). FORCE_COLOR=1 has the same effect."
	},
	noColor: {
		type: "boolean",
		description: "Disable colored output (default: auto). NO_COLOR=1 has the same effect."
	},
	timezone: {
		type: "string",
		short: "z",
		description: "Timezone for date grouping (e.g., UTC, America/New_York, Asia/Tokyo). Default: system timezone"
	},
	locale: {
		type: "string",
		short: "l",
		description: "Locale for date/time formatting (e.g., en-US, ja-JP, de-DE)",
		default: "en-CA"
	},
	jq: {
		type: "string",
		short: "q",
		description: "Process JSON output with jq command (requires jq binary, implies --json)"
	}
}, sharedCommandConfig = {
	args: sharedArgs,
	toKebab: true
};
var require_debug$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	let messages = [], level = 0;
	const debug$3 = (msg, min) => {
		if (level >= min) messages.push(msg);
	};
	debug$3.WARN = 1, debug$3.INFO = 2, debug$3.DEBUG = 3, debug$3.reset = () => {
		messages = [];
	}, debug$3.setDebugLevel = (v) => {
		level = v;
	}, debug$3.warn = (msg) => debug$3(msg, debug$3.WARN), debug$3.info = (msg) => debug$3(msg, debug$3.INFO), debug$3.debug = (msg) => debug$3(msg, debug$3.DEBUG), debug$3.debugMessages = () => messages, module.exports = debug$3;
})), require_ansi_regex = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = ({ onlyFirst = false } = {}) => {
		const pattern = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
		return new RegExp(pattern, onlyFirst ? void 0 : "g");
	};
})), require_strip_ansi = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const ansiRegex$1 = require_ansi_regex();
	module.exports = (string) => typeof string === "string" ? string.replace(ansiRegex$1(), "") : string;
})), require_is_fullwidth_code_point = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const isFullwidthCodePoint$1 = (codePoint) => {
		return Number.isNaN(codePoint) ? false : codePoint >= 4352 && (codePoint <= 4447 || codePoint === 9001 || codePoint === 9002 || 11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || 12880 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65131 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 262141);
	};
	module.exports = isFullwidthCodePoint$1, module.exports.default = isFullwidthCodePoint$1;
})), require_emoji_regex$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function() {
		return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
	};
})), require_string_width = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const stripAnsi$1 = require_strip_ansi(), isFullwidthCodePoint = require_is_fullwidth_code_point(), emojiRegex$1 = require_emoji_regex$1(), stringWidth$2 = (string) => {
		if (typeof string !== "string" || string.length === 0 || (string = stripAnsi$1(string), string.length === 0)) return 0;
		string = string.replace(emojiRegex$1(), "  ");
		let width = 0;
		for (let i = 0; i < string.length; i++) {
			const code = string.codePointAt(i);
			if (!(code <= 31 || code >= 127 && code <= 159) && !(code >= 768 && code <= 879)) {
				if (code > 65535) i++;
				width += isFullwidthCodePoint(code) ? 2 : 1;
			}
		}
		return width;
	};
	module.exports = stringWidth$2, module.exports.default = stringWidth$2;
})), require_utils = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const stringWidth$1 = require_string_width();
	function codeRegex(capture) {
		return capture ? /\u001b\[((?:\d*;){0,5}\d*)m/g : /\u001b\[(?:\d*;){0,5}\d*m/g;
	}
	function strlen(str) {
		let code = codeRegex(), stripped = ("" + str).replace(code, ""), split = stripped.split("\n");
		return split.reduce(function(memo, s) {
			return stringWidth$1(s) > memo ? stringWidth$1(s) : memo;
		}, 0);
	}
	function repeat(str, times) {
		return Array(times + 1).join(str);
	}
	function pad(str, len, pad$1, dir) {
		let length = strlen(str);
		if (len + 1 >= length) {
			let padlen = len - length;
			switch (dir) {
				case "right":
					str = repeat(pad$1, padlen) + str;
					break;
				case "center": {
					let right = Math.ceil(padlen / 2), left = padlen - right;
					str = repeat(pad$1, left) + str + repeat(pad$1, right);
					break;
				}
				default:
					str = str + repeat(pad$1, padlen);
					break;
			}
		}
		return str;
	}
	let codeCache = {};
	function addToCodeCache(name$1, on$1, off) {
		on$1 = "\x1B[" + on$1 + "m", off = "\x1B[" + off + "m", codeCache[on$1] = {
			set: name$1,
			to: true
		}, codeCache[off] = {
			set: name$1,
			to: false
		}, codeCache[name$1] = {
			on: on$1,
			off
		};
	}
	addToCodeCache("bold", 1, 22), addToCodeCache("italics", 3, 23), addToCodeCache("underline", 4, 24), addToCodeCache("inverse", 7, 27), addToCodeCache("strikethrough", 9, 29);
	function updateState(state, controlChars) {
		let controlCode = controlChars[1] ? parseInt(controlChars[1].split(";")[0]) : 0;
		if (controlCode >= 30 && controlCode <= 39 || controlCode >= 90 && controlCode <= 97) {
			state.lastForegroundAdded = controlChars[0];
			return;
		}
		if (controlCode >= 40 && controlCode <= 49 || controlCode >= 100 && controlCode <= 107) {
			state.lastBackgroundAdded = controlChars[0];
			return;
		}
		if (controlCode === 0) {
			for (let i in state)
 /* istanbul ignore else */
			if (Object.prototype.hasOwnProperty.call(state, i)) delete state[i];
			return;
		}
		let info$1 = codeCache[controlChars[0]];
		if (info$1) state[info$1.set] = info$1.to;
	}
	function readState(line) {
		let code = codeRegex(true), controlChars = code.exec(line), state = {};
		while (controlChars !== null) updateState(state, controlChars), controlChars = code.exec(line);
		return state;
	}
	function unwindState(state, ret) {
		let lastBackgroundAdded = state.lastBackgroundAdded, lastForegroundAdded = state.lastForegroundAdded;
		if (delete state.lastBackgroundAdded, delete state.lastForegroundAdded, Object.keys(state).forEach(function(key) {
			if (state[key]) ret += codeCache[key].off;
		}), lastBackgroundAdded && lastBackgroundAdded != "\x1B[49m") ret += "\x1B[49m";
		if (lastForegroundAdded && lastForegroundAdded != "\x1B[39m") ret += "\x1B[39m";
		return ret;
	}
	function rewindState(state, ret) {
		let lastBackgroundAdded = state.lastBackgroundAdded, lastForegroundAdded = state.lastForegroundAdded;
		if (delete state.lastBackgroundAdded, delete state.lastForegroundAdded, Object.keys(state).forEach(function(key) {
			if (state[key]) ret = codeCache[key].on + ret;
		}), lastBackgroundAdded && lastBackgroundAdded != "\x1B[49m") ret = lastBackgroundAdded + ret;
		if (lastForegroundAdded && lastForegroundAdded != "\x1B[39m") ret = lastForegroundAdded + ret;
		return ret;
	}
	function truncateWidth(str, desiredLength) {
		if (str.length === strlen(str)) return str.substr(0, desiredLength);
		while (strlen(str) > desiredLength) str = str.slice(0, -1);
		return str;
	}
	function truncateWidthWithAnsi(str, desiredLength) {
		let code = codeRegex(true), split = str.split(codeRegex()), splitIndex = 0, retLen = 0, ret = "", myArray, state = {};
		while (retLen < desiredLength) {
			myArray = code.exec(str);
			let toAdd = split[splitIndex];
			if (splitIndex++, retLen + strlen(toAdd) > desiredLength) toAdd = truncateWidth(toAdd, desiredLength - retLen);
			if (ret += toAdd, retLen += strlen(toAdd), retLen < desiredLength) {
				if (!myArray) break;
				ret += myArray[0], updateState(state, myArray);
			}
		}
		return unwindState(state, ret);
	}
	function truncate(str, desiredLength, truncateChar) {
		truncateChar = truncateChar || "";
		let lengthOfStr = strlen(str);
		if (lengthOfStr <= desiredLength) return str;
		desiredLength -= strlen(truncateChar);
		let ret = truncateWidthWithAnsi(str, desiredLength);
		ret += truncateChar;
		const hrefTag = "\x1B]8;;\x07";
		if (str.includes(hrefTag) && !ret.includes(hrefTag)) ret += hrefTag;
		return ret;
	}
	function defaultOptions() {
		return {
			chars: {
				top: "",
				"top-mid": "",
				"top-left": "",
				"top-right": "",
				bottom: "",
				"bottom-mid": "",
				"bottom-left": "",
				"bottom-right": "",
				left: "",
				"left-mid": "",
				mid: "",
				"mid-mid": "",
				right: "",
				"right-mid": "",
				middle: ""
			},
			truncate: "",
			colWidths: [],
			rowHeights: [],
			colAligns: [],
			rowAligns: [],
			style: {
				"padding-left": 1,
				"padding-right": 1,
				head: ["red"],
				border: ["grey"],
				compact: false
			},
			head: []
		};
	}
	function mergeOptions(options, defaults) {
		options = options || {}, defaults = defaults || defaultOptions();
		let ret = Object.assign({}, defaults, options);
		return ret.chars = Object.assign({}, defaults.chars, options.chars), ret.style = Object.assign({}, defaults.style, options.style), ret;
	}
	function wordWrap(maxLength, input) {
		let lines = [], split = input.split(/(\s+)/g), line = [], lineLength = 0, whitespace;
		for (let i = 0; i < split.length; i += 2) {
			let word = split[i], newLength = lineLength + strlen(word);
			if (lineLength > 0 && whitespace) newLength += whitespace.length;
			if (newLength > maxLength) {
				if (lineLength !== 0) lines.push(line.join(""));
				line = [word], lineLength = strlen(word);
			} else line.push(whitespace || "", word), lineLength = newLength;
			whitespace = split[i + 1];
		}
		if (lineLength) lines.push(line.join(""));
		return lines;
	}
	function textWrap(maxLength, input) {
		let lines = [], line = "";
		function pushLine(str, ws) {
			if (line.length && ws) line += ws;
			line += str;
			while (line.length > maxLength) lines.push(line.slice(0, maxLength)), line = line.slice(maxLength);
		}
		let split = input.split(/(\s+)/g);
		for (let i = 0; i < split.length; i += 2) pushLine(split[i], i && split[i - 1]);
		if (line.length) lines.push(line);
		return lines;
	}
	function multiLineWordWrap(maxLength, input, wrapOnWordBoundary = true) {
		let output = [];
		input = input.split("\n");
		const handler = wrapOnWordBoundary ? wordWrap : textWrap;
		for (let i = 0; i < input.length; i++) output.push.apply(output, handler(maxLength, input[i]));
		return output;
	}
	function colorizeLines(input) {
		let state = {}, output = [];
		for (let i = 0; i < input.length; i++) {
			let line = rewindState(state, input[i]);
			state = readState(line);
			let temp = Object.assign({}, state);
			output.push(unwindState(temp, line));
		}
		return output;
	}
	function hyperlink(url, text) {
		const OSC = "\x1B]", BEL = "\x07", SEP$1 = ";";
		return [
			OSC,
			"8",
			SEP$1,
			SEP$1,
			url || text,
			BEL,
			text,
			OSC,
			"8",
			SEP$1,
			SEP$1,
			BEL
		].join("");
	}
	module.exports = {
		strlen,
		repeat,
		pad,
		truncate,
		mergeOptions,
		wordWrap: multiLineWordWrap,
		colorizeLines,
		hyperlink
	};
})), require_styles = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var styles$1 = {};
	module["exports"] = styles$1;
	var codes = {
		reset: [0, 0],
		bold: [1, 22],
		dim: [2, 22],
		italic: [3, 23],
		underline: [4, 24],
		inverse: [7, 27],
		hidden: [8, 28],
		strikethrough: [9, 29],
		black: [30, 39],
		red: [31, 39],
		green: [32, 39],
		yellow: [33, 39],
		blue: [34, 39],
		magenta: [35, 39],
		cyan: [36, 39],
		white: [37, 39],
		gray: [90, 39],
		grey: [90, 39],
		brightRed: [91, 39],
		brightGreen: [92, 39],
		brightYellow: [93, 39],
		brightBlue: [94, 39],
		brightMagenta: [95, 39],
		brightCyan: [96, 39],
		brightWhite: [97, 39],
		bgBlack: [40, 49],
		bgRed: [41, 49],
		bgGreen: [42, 49],
		bgYellow: [43, 49],
		bgBlue: [44, 49],
		bgMagenta: [45, 49],
		bgCyan: [46, 49],
		bgWhite: [47, 49],
		bgGray: [100, 49],
		bgGrey: [100, 49],
		bgBrightRed: [101, 49],
		bgBrightGreen: [102, 49],
		bgBrightYellow: [103, 49],
		bgBrightBlue: [104, 49],
		bgBrightMagenta: [105, 49],
		bgBrightCyan: [106, 49],
		bgBrightWhite: [107, 49],
		blackBG: [40, 49],
		redBG: [41, 49],
		greenBG: [42, 49],
		yellowBG: [43, 49],
		blueBG: [44, 49],
		magentaBG: [45, 49],
		cyanBG: [46, 49],
		whiteBG: [47, 49]
	};
	Object.keys(codes).forEach(function(key) {
		var val = codes[key], style = styles$1[key] = [];
		style.open = "\x1B[" + val[0] + "m", style.close = "\x1B[" + val[1] + "m";
	});
})), require_has_flag = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function(flag, argv$1) {
		argv$1 = argv$1 || process.argv;
		var terminatorPos = argv$1.indexOf("--"), prefix = /^-{1,2}/.test(flag) ? "" : "--", pos = argv$1.indexOf(prefix + flag);
		return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
	};
})), require_supports_colors = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var os = __require("node:os"), hasFlag = require_has_flag(), env = process.env, forceColor = void 0;
	if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) forceColor = false;
	else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) forceColor = true;
	if ("FORCE_COLOR" in env) forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
	function translateLevel(level$1) {
		return level$1 === 0 ? false : {
			level: level$1,
			hasBasic: true,
			has256: level$1 >= 2,
			has16m: level$1 >= 3
		};
	}
	function supportsColor(stream) {
		if (forceColor === false) return 0;
		if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) return 3;
		if (hasFlag("color=256")) return 2;
		if (stream && !stream.isTTY && forceColor !== true) return 0;
		var min = forceColor ? 1 : 0;
		if (process.platform === "win32") {
			var osRelease = os.release().split(".");
			return Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586 ? Number(osRelease[2]) >= 14931 ? 3 : 2 : 1;
		}
		if ("CI" in env) return [
			"TRAVIS",
			"CIRCLECI",
			"APPVEYOR",
			"GITLAB_CI"
		].some(function(sign) {
			return sign in env;
		}) || env.CI_NAME === "codeship" ? 1 : min;
		if ("TEAMCITY_VERSION" in env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
		if ("TERM_PROGRAM" in env) {
			var version$2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
			switch (env.TERM_PROGRAM) {
				case "iTerm.app": return version$2 >= 3 ? 3 : 2;
				case "Hyper": return 3;
				case "Apple_Terminal": return 2;
			}
		}
		return /-256(color)?$/i.test(env.TERM) ? 2 : /^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM) || "COLORTERM" in env ? 1 : (env.TERM === "dumb", min);
	}
	function getSupportLevel(stream) {
		var level$1 = supportsColor(stream);
		return translateLevel(level$1);
	}
	module.exports = {
		supportsColor: getSupportLevel,
		stdout: getSupportLevel(process.stdout),
		stderr: getSupportLevel(process.stderr)
	};
})), require_trap = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module["exports"] = function runTheTrap(text, options) {
		var result = "";
		text = text || "Run the trap, drop the bass", text = text.split("");
		var trap = {
			a: [
				"@",
				"",
				"",
				"",
				"",
				"",
				""
			],
			b: [
				"",
				"",
				"",
				"",
				"",
				""
			],
			c: [
				"",
				"",
				""
			],
			d: [
				"",
				"",
				"",
				"",
				"",
				""
			],
			e: [
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			],
			f: [""],
			g: [""],
			h: [
				"",
				"",
				"",
				"",
				"",
				""
			],
			i: [""],
			j: [""],
			k: [
				"",
				"",
				"",
				""
			],
			l: [""],
			m: [
				"",
				"",
				"",
				"",
				"",
				""
			],
			n: [
				"",
				"",
				"",
				"",
				"",
				""
			],
			o: [
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			],
			p: ["", ""],
			q: [""],
			r: [
				"",
				"",
				"",
				"",
				"",
				""
			],
			s: [
				"",
				"",
				"",
				""
			],
			t: [
				"",
				"",
				""
			],
			u: ["", ""],
			v: [""],
			w: [
				"",
				"",
				"",
				""
			],
			x: [
				"",
				"",
				"",
				""
			],
			y: [
				"",
				"",
				""
			],
			z: ["", ""]
		};
		return text.forEach(function(c) {
			c = c.toLowerCase();
			var chars = trap[c] || [" "], rand = Math.floor(Math.random() * chars.length);
			if (typeof trap[c] !== "undefined") result += trap[c][rand];
			else result += c;
		}), result;
	};
})), require_zalgo = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module["exports"] = function zalgo(text, options) {
		text = text || "   he is here   ";
		var soul = {
			"up": [
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			],
			"down": [
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			],
			"mid": [
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				" "
			]
		}, all = [].concat(soul.up, soul.down, soul.mid);
		function randomNumber(range) {
			var r = Math.floor(Math.random() * range);
			return r;
		}
		function isChar(character) {
			var bool = false;
			return all.filter(function(i) {
				bool = i === character;
			}), bool;
		}
		function heComes(text$1, options$1) {
			var result = "", counts, l;
			for (l in options$1 = options$1 || {}, options$1["up"] = typeof options$1["up"] !== "undefined" ? options$1["up"] : true, options$1["mid"] = typeof options$1["mid"] !== "undefined" ? options$1["mid"] : true, options$1["down"] = typeof options$1["down"] !== "undefined" ? options$1["down"] : true, options$1["size"] = typeof options$1["size"] !== "undefined" ? options$1["size"] : "maxi", text$1 = text$1.split(""), text$1) {
				if (isChar(l)) continue;
				switch (result = result + text$1[l], counts = {
					"up": 0,
					"down": 0,
					"mid": 0
				}, options$1.size) {
					case "mini":
						counts.up = randomNumber(8), counts.mid = randomNumber(2), counts.down = randomNumber(8);
						break;
					case "maxi":
						counts.up = randomNumber(16) + 3, counts.mid = randomNumber(4) + 1, counts.down = randomNumber(64) + 3;
						break;
					default:
						counts.up = randomNumber(8) + 1, counts.mid = randomNumber(6) / 2, counts.down = randomNumber(8) + 1;
						break;
				}
				var arr = [
					"up",
					"mid",
					"down"
				];
				for (var d in arr) for (var index = arr[d], i = 0; i <= counts[index]; i++) if (options$1[index]) result = result + soul[index][randomNumber(soul[index].length)];
			}
			return result;
		}
		return heComes(text, options);
	};
})), require_america = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module["exports"] = function(colors$2) {
		return function(letter, i, exploded) {
			if (letter === " ") return letter;
			switch (i % 3) {
				case 0: return colors$2.red(letter);
				case 1: return colors$2.white(letter);
				case 2: return colors$2.blue(letter);
			}
		};
	};
})), require_zebra = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module["exports"] = function(colors$2) {
		return function(letter, i, exploded) {
			return i % 2 === 0 ? letter : colors$2.inverse(letter);
		};
	};
})), require_rainbow = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module["exports"] = function(colors$2) {
		var rainbowColors = [
			"red",
			"yellow",
			"green",
			"blue",
			"magenta"
		];
		return function(letter, i, exploded) {
			return letter === " " ? letter : colors$2[rainbowColors[i++ % rainbowColors.length]](letter);
		};
	};
})), require_random = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module["exports"] = function(colors$2) {
		var available = [
			"underline",
			"inverse",
			"grey",
			"yellow",
			"red",
			"green",
			"blue",
			"white",
			"cyan",
			"magenta",
			"brightYellow",
			"brightRed",
			"brightGreen",
			"brightBlue",
			"brightWhite",
			"brightCyan",
			"brightMagenta"
		];
		return function(letter, i, exploded) {
			return letter === " " ? letter : colors$2[available[Math.round(Math.random() * (available.length - 2))]](letter);
		};
	};
})), require_colors = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var colors$1 = {};
	module["exports"] = colors$1, colors$1.themes = {};
	var util = __require("node:util"), ansiStyles = colors$1.styles = require_styles(), defineProps = Object.defineProperties, newLineRegex = /* @__PURE__ */ new RegExp(/[\r\n]+/g);
	if (colors$1.supportsColor = require_supports_colors().supportsColor, typeof colors$1.enabled === "undefined") colors$1.enabled = colors$1.supportsColor() !== false;
	colors$1.enable = function() {
		colors$1.enabled = true;
	}, colors$1.disable = function() {
		colors$1.enabled = false;
	}, colors$1.stripColors = colors$1.strip = function(str) {
		return ("" + str).replace(/\x1B\[\d+m/g, "");
	}, colors$1.stylize = function stylize(str, style) {
		if (!colors$1.enabled) return str + "";
		var styleMap = ansiStyles[style];
		return !styleMap && style in colors$1 ? colors$1[style](str) : styleMap.open + str + styleMap.close;
	};
	var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g, escapeStringRegexp = function(str) {
		if (typeof str !== "string") throw new TypeError("Expected a string");
		return str.replace(matchOperatorsRe, "\\$&");
	};
	function build(_styles) {
		var builder = function builder$1() {
			return applyStyle.apply(builder$1, arguments);
		};
		return builder._styles = _styles, builder.__proto__ = proto, builder;
	}
	var styles = (function() {
		var ret = {};
		return ansiStyles.grey = ansiStyles.gray, Object.keys(ansiStyles).forEach(function(key) {
			ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g"), ret[key] = { get: function() {
				return build(this._styles.concat(key));
			} };
		}), ret;
	})(), proto = defineProps(function colors$2() {}, styles);
	function applyStyle() {
		var args = Array.prototype.slice.call(arguments), str = args.map(function(arg) {
			return arg != null && arg.constructor === String ? arg : util.inspect(arg);
		}).join(" ");
		if (!colors$1.enabled || !str) return str;
		var newLinesPresent = str.indexOf("\n") != -1, nestedStyles = this._styles, i = nestedStyles.length;
		while (i--) {
			var code = ansiStyles[nestedStyles[i]];
			if (str = code.open + str.replace(code.closeRe, code.open) + code.close, newLinesPresent) str = str.replace(newLineRegex, function(match) {
				return code.close + match + code.open;
			});
		}
		return str;
	}
	colors$1.setTheme = function(theme) {
		if (typeof theme === "string") {
			console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
			return;
		}
		for (var style in theme) (function(style$1) {
			colors$1[style$1] = function(str) {
				if (typeof theme[style$1] === "object") {
					var out = str;
					for (var i in theme[style$1]) out = colors$1[theme[style$1][i]](out);
					return out;
				}
				return colors$1[theme[style$1]](str);
			};
		})(style);
	};
	function init() {
		var ret = {};
		return Object.keys(styles).forEach(function(name$1) {
			ret[name$1] = { get: function() {
				return build([name$1]);
			} };
		}), ret;
	}
	var sequencer = function sequencer$1(map$1, str) {
		var exploded = str.split("");
		return exploded = exploded.map(map$1), exploded.join("");
	};
	for (var map in colors$1.trap = require_trap(), colors$1.zalgo = require_zalgo(), colors$1.maps = {}, colors$1.maps.america = require_america()(colors$1), colors$1.maps.zebra = require_zebra()(colors$1), colors$1.maps.rainbow = require_rainbow()(colors$1), colors$1.maps.random = require_random()(colors$1), colors$1.maps) (function(map$1) {
		colors$1[map$1] = function(str) {
			return sequencer(colors$1.maps[map$1], str);
		};
	})(map);
	defineProps(colors$1, init());
})), require_safe = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var colors = require_colors();
	module["exports"] = colors;
})), require_cell = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { info, debug: debug$2 } = require_debug$1(), utils$1 = require_utils();
	var Cell$1 = class Cell$1 {
		constructor(options) {
			this.setOptions(options), this.x = null, this.y = null;
		}
		setOptions(options) {
			if ([
				"boolean",
				"number",
				"bigint",
				"string"
			].indexOf(typeof options) !== -1) options = { content: "" + options };
			options = options || {}, this.options = options;
			let content = options.content;
			if ([
				"boolean",
				"number",
				"bigint",
				"string"
			].indexOf(typeof content) !== -1) this.content = String(content);
			else if (!content) this.content = this.options.href || "";
			else throw new Error("Content needs to be a primitive, got: " + typeof content);
			if (this.colSpan = options.colSpan || 1, this.rowSpan = options.rowSpan || 1, this.options.href) Object.defineProperty(this, "href", { get() {
				return this.options.href;
			} });
		}
		mergeTableOptions(tableOptions, cells) {
			this.cells = cells;
			let optionsChars = this.options.chars || {}, tableChars = tableOptions.chars, chars = this.chars = {};
			CHAR_NAMES.forEach(function(name$1) {
				setOption(optionsChars, tableChars, name$1, chars);
			}), this.truncate = this.options.truncate || tableOptions.truncate;
			let style = this.options.style = this.options.style || {}, tableStyle = tableOptions.style;
			setOption(style, tableStyle, "padding-left", this), setOption(style, tableStyle, "padding-right", this), this.head = style.head || tableStyle.head, this.border = style.border || tableStyle.border, this.fixedWidth = tableOptions.colWidths[this.x], this.lines = this.computeLines(tableOptions), this.desiredWidth = utils$1.strlen(this.content) + this.paddingLeft + this.paddingRight, this.desiredHeight = this.lines.length;
		}
		computeLines(tableOptions) {
			const tableWordWrap = tableOptions.wordWrap || tableOptions.textWrap, { wordWrap: wordWrap$1 = tableWordWrap } = this.options;
			if (this.fixedWidth && wordWrap$1) {
				if (this.fixedWidth -= this.paddingLeft + this.paddingRight, this.colSpan) {
					let i = 1;
					while (i < this.colSpan) this.fixedWidth += tableOptions.colWidths[this.x + i], i++;
				}
				const { wrapOnWordBoundary: tableWrapOnWordBoundary = true } = tableOptions, { wrapOnWordBoundary = tableWrapOnWordBoundary } = this.options;
				return this.wrapLines(utils$1.wordWrap(this.fixedWidth, this.content, wrapOnWordBoundary));
			}
			return this.wrapLines(this.content.split("\n"));
		}
		wrapLines(computedLines) {
			const lines = utils$1.colorizeLines(computedLines);
			return this.href ? lines.map((line) => utils$1.hyperlink(this.href, line)) : lines;
		}
		init(tableOptions) {
			let x = this.x, y = this.y;
			this.widths = tableOptions.colWidths.slice(x, x + this.colSpan), this.heights = tableOptions.rowHeights.slice(y, y + this.rowSpan), this.width = this.widths.reduce(sumPlusOne, -1), this.height = this.heights.reduce(sumPlusOne, -1), this.hAlign = this.options.hAlign || tableOptions.colAligns[x], this.vAlign = this.options.vAlign || tableOptions.rowAligns[y], this.drawRight = x + this.colSpan == tableOptions.colWidths.length;
		}
		draw(lineNum, spanningCell) {
			if (lineNum == "top") return this.drawTop(this.drawRight);
			if (lineNum == "bottom") return this.drawBottom(this.drawRight);
			let content = utils$1.truncate(this.content, 10, this.truncate);
			if (!lineNum) info(`${this.y}-${this.x}: ${this.rowSpan - lineNum}x${this.colSpan} Cell ${content}`);
			let padLen = Math.max(this.height - this.lines.length, 0), padTop;
			switch (this.vAlign) {
				case "center":
					padTop = Math.ceil(padLen / 2);
					break;
				case "bottom":
					padTop = padLen;
					break;
				default: padTop = 0;
			}
			if (lineNum < padTop || lineNum >= padTop + this.lines.length) return this.drawEmpty(this.drawRight, spanningCell);
			let forceTruncation = this.lines.length > this.height && lineNum + 1 >= this.height;
			return this.drawLine(lineNum - padTop, this.drawRight, forceTruncation, spanningCell);
		}
		drawTop(drawRight) {
			let content = [];
			if (this.cells) this.widths.forEach(function(width, index) {
				content.push(this._topLeftChar(index)), content.push(utils$1.repeat(this.chars[this.y == 0 ? "top" : "mid"], width));
			}, this);
			else content.push(this._topLeftChar(0)), content.push(utils$1.repeat(this.chars[this.y == 0 ? "top" : "mid"], this.width));
			if (drawRight) content.push(this.chars[this.y == 0 ? "topRight" : "rightMid"]);
			return this.wrapWithStyleColors("border", content.join(""));
		}
		_topLeftChar(offset) {
			let x = this.x + offset, leftChar;
			if (this.y == 0) leftChar = x == 0 ? "topLeft" : offset == 0 ? "topMid" : "top";
			else if (x == 0) leftChar = "leftMid";
			else if (leftChar = offset == 0 ? "midMid" : "bottomMid", this.cells) {
				let spanAbove = this.cells[this.y - 1][x] instanceof Cell$1.ColSpanCell;
				if (spanAbove) leftChar = offset == 0 ? "topMid" : "mid";
				if (offset == 0) {
					let i = 1;
					while (this.cells[this.y][x - i] instanceof Cell$1.ColSpanCell) i++;
					if (this.cells[this.y][x - i] instanceof Cell$1.RowSpanCell) leftChar = "leftMid";
				}
			}
			return this.chars[leftChar];
		}
		wrapWithStyleColors(styleProperty, content) {
			if (this[styleProperty] && this[styleProperty].length) try {
				let colors$2 = require_safe();
				for (let i = this[styleProperty].length - 1; i >= 0; i--) colors$2 = colors$2[this[styleProperty][i]];
				return colors$2(content);
			} catch (e) {
				return content;
			}
			else return content;
		}
		drawLine(lineNum, drawRight, forceTruncationSymbol, spanningCell) {
			let left = this.chars[this.x == 0 ? "left" : "middle"];
			if (this.x && spanningCell && this.cells) {
				let cellLeft = this.cells[this.y + spanningCell][this.x - 1];
				while (cellLeft instanceof ColSpanCell$1) cellLeft = this.cells[cellLeft.y][cellLeft.x - 1];
				if (!(cellLeft instanceof RowSpanCell$1)) left = this.chars["rightMid"];
			}
			let leftPadding = utils$1.repeat(" ", this.paddingLeft), right = drawRight ? this.chars["right"] : "", rightPadding = utils$1.repeat(" ", this.paddingRight), line = this.lines[lineNum], len = this.width - (this.paddingLeft + this.paddingRight);
			if (forceTruncationSymbol) line += this.truncate || "";
			let content = utils$1.truncate(line, len, this.truncate);
			return content = utils$1.pad(content, len, " ", this.hAlign), content = leftPadding + content + rightPadding, this.stylizeLine(left, content, right);
		}
		stylizeLine(left, content, right) {
			if (left = this.wrapWithStyleColors("border", left), right = this.wrapWithStyleColors("border", right), this.y === 0) content = this.wrapWithStyleColors("head", content);
			return left + content + right;
		}
		drawBottom(drawRight) {
			let left = this.chars[this.x == 0 ? "bottomLeft" : "bottomMid"], content = utils$1.repeat(this.chars.bottom, this.width), right = drawRight ? this.chars["bottomRight"] : "";
			return this.wrapWithStyleColors("border", left + content + right);
		}
		drawEmpty(drawRight, spanningCell) {
			let left = this.chars[this.x == 0 ? "left" : "middle"];
			if (this.x && spanningCell && this.cells) {
				let cellLeft = this.cells[this.y + spanningCell][this.x - 1];
				while (cellLeft instanceof ColSpanCell$1) cellLeft = this.cells[cellLeft.y][cellLeft.x - 1];
				if (!(cellLeft instanceof RowSpanCell$1)) left = this.chars["rightMid"];
			}
			let right = drawRight ? this.chars["right"] : "", content = utils$1.repeat(" ", this.width);
			return this.stylizeLine(left, content, right);
		}
	}, ColSpanCell$1 = class {
		constructor() {}
		draw(lineNum) {
			if (typeof lineNum === "number") debug$2(`${this.y}-${this.x}: 1x1 ColSpanCell`);
			return "";
		}
		init() {}
		mergeTableOptions() {}
	}, RowSpanCell$1 = class {
		constructor(originalCell) {
			this.originalCell = originalCell;
		}
		init(tableOptions) {
			let y = this.y, originalY = this.originalCell.y;
			this.cellOffset = y - originalY, this.offset = findDimension(tableOptions.rowHeights, originalY, this.cellOffset);
		}
		draw(lineNum) {
			return lineNum == "top" ? this.originalCell.draw(this.offset, this.cellOffset) : lineNum == "bottom" ? this.originalCell.draw("bottom") : (debug$2(`${this.y}-${this.x}: 1x${this.colSpan} RowSpanCell for ${this.originalCell.content}`), this.originalCell.draw(this.offset + 1 + lineNum));
		}
		mergeTableOptions() {}
	};
	function firstDefined(...args) {
		return args.filter((v) => v !== void 0 && v !== null).shift();
	}
	function setOption(objA, objB, nameB, targetObj) {
		let nameA = nameB.split("-");
		if (nameA.length > 1) nameA[1] = nameA[1].charAt(0).toUpperCase() + nameA[1].substr(1), nameA = nameA.join(""), targetObj[nameA] = firstDefined(objA[nameA], objA[nameB], objB[nameA], objB[nameB]);
		else targetObj[nameB] = firstDefined(objA[nameB], objB[nameB]);
	}
	function findDimension(dimensionTable, startingIndex, span) {
		let ret = dimensionTable[startingIndex];
		for (let i = 1; i < span; i++) ret += 1 + dimensionTable[startingIndex + i];
		return ret;
	}
	function sumPlusOne(a$1, b) {
		return a$1 + b + 1;
	}
	let CHAR_NAMES = [
		"top",
		"top-mid",
		"top-left",
		"top-right",
		"bottom",
		"bottom-mid",
		"bottom-left",
		"bottom-right",
		"left",
		"left-mid",
		"mid",
		"mid-mid",
		"right",
		"right-mid",
		"middle"
	];
	module.exports = Cell$1, module.exports.ColSpanCell = ColSpanCell$1, module.exports.RowSpanCell = RowSpanCell$1;
})), require_layout_manager = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { warn, debug: debug$1 } = require_debug$1(), Cell = require_cell(), { ColSpanCell, RowSpanCell } = Cell;
	(function() {
		function next(alloc, col) {
			return alloc[col] > 0 ? next(alloc, col + 1) : col;
		}
		function layoutTable(table) {
			let alloc = {};
			table.forEach(function(row, rowIndex) {
				let col = 0;
				row.forEach(function(cell) {
					cell.y = rowIndex, cell.x = rowIndex ? next(alloc, col) : col;
					const rowSpan = cell.rowSpan || 1, colSpan = cell.colSpan || 1;
					if (rowSpan > 1) for (let cs = 0; cs < colSpan; cs++) alloc[cell.x + cs] = rowSpan;
					col = cell.x + colSpan;
				}), Object.keys(alloc).forEach((idx) => {
					if (alloc[idx]--, alloc[idx] < 1) delete alloc[idx];
				});
			});
		}
		function maxWidth(table) {
			let mw = 0;
			return table.forEach(function(row) {
				row.forEach(function(cell) {
					mw = Math.max(mw, cell.x + (cell.colSpan || 1));
				});
			}), mw;
		}
		function maxHeight(table) {
			return table.length;
		}
		function cellsConflict(cell1, cell2) {
			let yMin1 = cell1.y, yMax1 = cell1.y - 1 + (cell1.rowSpan || 1), yMin2 = cell2.y, yMax2 = cell2.y - 1 + (cell2.rowSpan || 1), yConflict = !(yMin1 > yMax2 || yMin2 > yMax1), xMin1 = cell1.x, xMax1 = cell1.x - 1 + (cell1.colSpan || 1), xMin2 = cell2.x, xMax2 = cell2.x - 1 + (cell2.colSpan || 1), xConflict = !(xMin1 > xMax2 || xMin2 > xMax1);
			return yConflict && xConflict;
		}
		function conflictExists(rows, x, y) {
			let i_max = Math.min(rows.length - 1, y), cell = {
				x,
				y
			};
			for (let i = 0; i <= i_max; i++) {
				let row = rows[i];
				for (let j = 0; j < row.length; j++) if (cellsConflict(cell, row[j])) return true;
			}
			return false;
		}
		function allBlank(rows, y, xMin, xMax) {
			for (let x = xMin; x < xMax; x++) if (conflictExists(rows, x, y)) return false;
			return true;
		}
		function addRowSpanCells(table) {
			table.forEach(function(row, rowIndex) {
				row.forEach(function(cell) {
					for (let i = 1; i < cell.rowSpan; i++) {
						let rowSpanCell = new RowSpanCell(cell);
						rowSpanCell.x = cell.x, rowSpanCell.y = cell.y + i, rowSpanCell.colSpan = cell.colSpan, insertCell(rowSpanCell, table[rowIndex + i]);
					}
				});
			});
		}
		function addColSpanCells(cellRows) {
			for (let rowIndex = cellRows.length - 1; rowIndex >= 0; rowIndex--) {
				let cellColumns = cellRows[rowIndex];
				for (let columnIndex = 0; columnIndex < cellColumns.length; columnIndex++) {
					let cell = cellColumns[columnIndex];
					for (let k = 1; k < cell.colSpan; k++) {
						let colSpanCell = new ColSpanCell();
						colSpanCell.x = cell.x + k, colSpanCell.y = cell.y, cellColumns.splice(columnIndex + 1, 0, colSpanCell);
					}
				}
			}
		}
		function insertCell(cell, row) {
			let x = 0;
			while (x < row.length && row[x].x < cell.x) x++;
			row.splice(x, 0, cell);
		}
		function fillInTable(table) {
			let h_max = maxHeight(table), w_max = maxWidth(table);
			debug$1(`Max rows: ${h_max}; Max cols: ${w_max}`);
			for (let y = 0; y < h_max; y++) for (let x = 0; x < w_max; x++) if (!conflictExists(table, x, y)) {
				let opts = {
					x,
					y,
					colSpan: 1,
					rowSpan: 1
				};
				x++;
				while (x < w_max && !conflictExists(table, x, y)) opts.colSpan++, x++;
				let y2 = y + 1;
				while (y2 < h_max && allBlank(table, y2, opts.x, opts.x + opts.colSpan)) opts.rowSpan++, y2++;
				let cell = new Cell(opts);
				cell.x = opts.x, cell.y = opts.y, warn(`Missing cell at ${cell.y}-${cell.x}.`), insertCell(cell, table[y]);
			}
		}
		function generateCells(rows) {
			return rows.map(function(row) {
				if (!Array.isArray(row)) {
					let key = Object.keys(row)[0];
					if (row = row[key], Array.isArray(row)) row = row.slice(), row.unshift(key);
					else row = [key, row];
				}
				return row.map(function(cell) {
					return new Cell(cell);
				});
			});
		}
		function makeTableLayout(rows) {
			let cellRows = generateCells(rows);
			return layoutTable(cellRows), fillInTable(cellRows), addRowSpanCells(cellRows), addColSpanCells(cellRows), cellRows;
		}
		module.exports = {
			makeTableLayout,
			layoutTable,
			addRowSpanCells,
			maxWidth,
			fillInTable,
			computeWidths: makeComputeWidths("colSpan", "desiredWidth", "x", 1),
			computeHeights: makeComputeWidths("rowSpan", "desiredHeight", "y", 1)
		};
	})();
	function makeComputeWidths(colSpan, desiredWidth, x, forcedMin) {
		return function(vals, table) {
			let result = [], spanners = [], auto = {};
			table.forEach(function(row) {
				row.forEach(function(cell) {
					if ((cell[colSpan] || 1) > 1) spanners.push(cell);
					else result[cell[x]] = Math.max(result[cell[x]] || 0, cell[desiredWidth] || 0, forcedMin);
				});
			}), vals.forEach(function(val, index) {
				if (typeof val === "number") result[index] = val;
			});
			for (let k = spanners.length - 1; k >= 0; k--) {
				let cell = spanners[k], span = cell[colSpan], col = cell[x], existingWidth = result[col], editableCols = typeof vals[col] === "number" ? 0 : 1;
				if (typeof existingWidth === "number") {
					for (let i = 1; i < span; i++) if (existingWidth += 1 + result[col + i], typeof vals[col + i] !== "number") editableCols++;
				} else if (existingWidth = desiredWidth === "desiredWidth" ? cell.desiredWidth - 1 : 1, !auto[col] || auto[col] < existingWidth) auto[col] = existingWidth;
				if (cell[desiredWidth] > existingWidth) {
					let i = 0;
					while (editableCols > 0 && cell[desiredWidth] > existingWidth) {
						if (typeof vals[col + i] !== "number") {
							let dif = Math.round((cell[desiredWidth] - existingWidth) / editableCols);
							existingWidth += dif, result[col + i] += dif, editableCols--;
						}
						i++;
					}
				}
			}
			Object.assign(vals, result, auto);
			for (let j = 0; j < vals.length; j++) vals[j] = Math.max(forcedMin, vals[j] || 0);
		};
	}
})), require_table = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const debug = require_debug$1(), utils = require_utils(), tableLayout = require_layout_manager();
	var Table$1 = class extends Array {
		constructor(opts) {
			super();
			const options = utils.mergeOptions(opts);
			if (Object.defineProperty(this, "options", {
				value: options,
				enumerable: options.debug
			}), options.debug) {
				switch (typeof options.debug) {
					case "boolean":
						debug.setDebugLevel(debug.WARN);
						break;
					case "number":
						debug.setDebugLevel(options.debug);
						break;
					case "string":
						debug.setDebugLevel(parseInt(options.debug, 10));
						break;
					default: debug.setDebugLevel(debug.WARN), debug.warn(`Debug option is expected to be boolean, number, or string. Received a ${typeof options.debug}`);
				}
				Object.defineProperty(this, "messages", { get() {
					return debug.debugMessages();
				} });
			}
		}
		toString() {
			let array = this, headersPresent = this.options.head && this.options.head.length;
			if (headersPresent) {
				if (array = [this.options.head], this.length) array.push.apply(array, this);
			} else this.options.style.head = [];
			let cells = tableLayout.makeTableLayout(array);
			cells.forEach(function(row) {
				row.forEach(function(cell) {
					cell.mergeTableOptions(this.options, cells);
				}, this);
			}, this), tableLayout.computeWidths(this.options.colWidths, cells), tableLayout.computeHeights(this.options.rowHeights, cells), cells.forEach(function(row) {
				row.forEach(function(cell) {
					cell.init(this.options);
				}, this);
			}, this);
			let result = [];
			for (let rowIndex = 0; rowIndex < cells.length; rowIndex++) {
				let row = cells[rowIndex], heightOfRow = this.options.rowHeights[rowIndex];
				if (rowIndex === 0 || !this.options.style.compact || rowIndex == 1 && headersPresent) doDraw(row, "top", result);
				for (let lineNum = 0; lineNum < heightOfRow; lineNum++) doDraw(row, lineNum, result);
				if (rowIndex + 1 == cells.length) doDraw(row, "bottom", result);
			}
			return result.join("\n");
		}
		get width() {
			let str = this.toString().split("\n");
			return str[0].length;
		}
	};
	Table$1.reset = () => debug.reset();
	function doDraw(row, lineNum, result) {
		let line = [];
		row.forEach(function(cell) {
			line.push(cell.draw(lineNum));
		});
		let str = line.join("");
		if (str.length) result.push(str);
	}
	module.exports = Table$1;
})), require_cli_table3 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require_table();
})), import_cli_table3 = /* @__PURE__ */ __toESM(require_cli_table3(), 1);
function ansiRegex({ onlyFirst = false } = {}) {
	const ST = "(?:\\u0007|\\u001B\\u005C|\\u009C)", pattern = [`[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?${ST})`, "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"].join("|");
	return new RegExp(pattern, onlyFirst ? void 0 : "g");
}
const regex = ansiRegex();
function stripAnsi(string) {
	if (typeof string !== "string") throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
	return string.replace(regex, "");
}
function isAmbiguous(x) {
	return x === 161 || x === 164 || x === 167 || x === 168 || x === 170 || x === 173 || x === 174 || x >= 176 && x <= 180 || x >= 182 && x <= 186 || x >= 188 && x <= 191 || x === 198 || x === 208 || x === 215 || x === 216 || x >= 222 && x <= 225 || x === 230 || x >= 232 && x <= 234 || x === 236 || x === 237 || x === 240 || x === 242 || x === 243 || x >= 247 && x <= 250 || x === 252 || x === 254 || x === 257 || x === 273 || x === 275 || x === 283 || x === 294 || x === 295 || x === 299 || x >= 305 && x <= 307 || x === 312 || x >= 319 && x <= 322 || x === 324 || x >= 328 && x <= 331 || x === 333 || x === 338 || x === 339 || x === 358 || x === 359 || x === 363 || x === 462 || x === 464 || x === 466 || x === 468 || x === 470 || x === 472 || x === 474 || x === 476 || x === 593 || x === 609 || x === 708 || x === 711 || x >= 713 && x <= 715 || x === 717 || x === 720 || x >= 728 && x <= 731 || x === 733 || x === 735 || x >= 768 && x <= 879 || x >= 913 && x <= 929 || x >= 931 && x <= 937 || x >= 945 && x <= 961 || x >= 963 && x <= 969 || x === 1025 || x >= 1040 && x <= 1103 || x === 1105 || x === 8208 || x >= 8211 && x <= 8214 || x === 8216 || x === 8217 || x === 8220 || x === 8221 || x >= 8224 && x <= 8226 || x >= 8228 && x <= 8231 || x === 8240 || x === 8242 || x === 8243 || x === 8245 || x === 8251 || x === 8254 || x === 8308 || x === 8319 || x >= 8321 && x <= 8324 || x === 8364 || x === 8451 || x === 8453 || x === 8457 || x === 8467 || x === 8470 || x === 8481 || x === 8482 || x === 8486 || x === 8491 || x === 8531 || x === 8532 || x >= 8539 && x <= 8542 || x >= 8544 && x <= 8555 || x >= 8560 && x <= 8569 || x === 8585 || x >= 8592 && x <= 8601 || x === 8632 || x === 8633 || x === 8658 || x === 8660 || x === 8679 || x === 8704 || x === 8706 || x === 8707 || x === 8711 || x === 8712 || x === 8715 || x === 8719 || x === 8721 || x === 8725 || x === 8730 || x >= 8733 && x <= 8736 || x === 8739 || x === 8741 || x >= 8743 && x <= 8748 || x === 8750 || x >= 8756 && x <= 8759 || x === 8764 || x === 8765 || x === 8776 || x === 8780 || x === 8786 || x === 8800 || x === 8801 || x >= 8804 && x <= 8807 || x === 8810 || x === 8811 || x === 8814 || x === 8815 || x === 8834 || x === 8835 || x === 8838 || x === 8839 || x === 8853 || x === 8857 || x === 8869 || x === 8895 || x === 8978 || x >= 9312 && x <= 9449 || x >= 9451 && x <= 9547 || x >= 9552 && x <= 9587 || x >= 9600 && x <= 9615 || x >= 9618 && x <= 9621 || x === 9632 || x === 9633 || x >= 9635 && x <= 9641 || x === 9650 || x === 9651 || x === 9654 || x === 9655 || x === 9660 || x === 9661 || x === 9664 || x === 9665 || x >= 9670 && x <= 9672 || x === 9675 || x >= 9678 && x <= 9681 || x >= 9698 && x <= 9701 || x === 9711 || x === 9733 || x === 9734 || x === 9737 || x === 9742 || x === 9743 || x === 9756 || x === 9758 || x === 9792 || x === 9794 || x === 9824 || x === 9825 || x >= 9827 && x <= 9829 || x >= 9831 && x <= 9834 || x === 9836 || x === 9837 || x === 9839 || x === 9886 || x === 9887 || x === 9919 || x >= 9926 && x <= 9933 || x >= 9935 && x <= 9939 || x >= 9941 && x <= 9953 || x === 9955 || x === 9960 || x === 9961 || x >= 9963 && x <= 9969 || x === 9972 || x >= 9974 && x <= 9977 || x === 9979 || x === 9980 || x === 9982 || x === 9983 || x === 10045 || x >= 10102 && x <= 10111 || x >= 11094 && x <= 11097 || x >= 12872 && x <= 12879 || x >= 57344 && x <= 63743 || x >= 65024 && x <= 65039 || x === 65533 || x >= 127232 && x <= 127242 || x >= 127248 && x <= 127277 || x >= 127280 && x <= 127337 || x >= 127344 && x <= 127373 || x === 127375 || x === 127376 || x >= 127387 && x <= 127404 || x >= 917760 && x <= 917999 || x >= 983040 && x <= 1048573 || x >= 1048576 && x <= 1114109;
}
function isFullWidth(x) {
	return x === 12288 || x >= 65281 && x <= 65376 || x >= 65504 && x <= 65510;
}
function isWide(x) {
	return x >= 4352 && x <= 4447 || x === 8986 || x === 8987 || x === 9001 || x === 9002 || x >= 9193 && x <= 9196 || x === 9200 || x === 9203 || x === 9725 || x === 9726 || x === 9748 || x === 9749 || x >= 9776 && x <= 9783 || x >= 9800 && x <= 9811 || x === 9855 || x >= 9866 && x <= 9871 || x === 9875 || x === 9889 || x === 9898 || x === 9899 || x === 9917 || x === 9918 || x === 9924 || x === 9925 || x === 9934 || x === 9940 || x === 9962 || x === 9970 || x === 9971 || x === 9973 || x === 9978 || x === 9981 || x === 9989 || x === 9994 || x === 9995 || x === 10024 || x === 10060 || x === 10062 || x >= 10067 && x <= 10069 || x === 10071 || x >= 10133 && x <= 10135 || x === 10160 || x === 10175 || x === 11035 || x === 11036 || x === 11088 || x === 11093 || x >= 11904 && x <= 11929 || x >= 11931 && x <= 12019 || x >= 12032 && x <= 12245 || x >= 12272 && x <= 12287 || x >= 12289 && x <= 12350 || x >= 12353 && x <= 12438 || x >= 12441 && x <= 12543 || x >= 12549 && x <= 12591 || x >= 12593 && x <= 12686 || x >= 12688 && x <= 12773 || x >= 12783 && x <= 12830 || x >= 12832 && x <= 12871 || x >= 12880 && x <= 42124 || x >= 42128 && x <= 42182 || x >= 43360 && x <= 43388 || x >= 44032 && x <= 55203 || x >= 63744 && x <= 64255 || x >= 65040 && x <= 65049 || x >= 65072 && x <= 65106 || x >= 65108 && x <= 65126 || x >= 65128 && x <= 65131 || x >= 94176 && x <= 94180 || x === 94192 || x === 94193 || x >= 94208 && x <= 100343 || x >= 100352 && x <= 101589 || x >= 101631 && x <= 101640 || x >= 110576 && x <= 110579 || x >= 110581 && x <= 110587 || x === 110589 || x === 110590 || x >= 110592 && x <= 110882 || x === 110898 || x >= 110928 && x <= 110930 || x === 110933 || x >= 110948 && x <= 110951 || x >= 110960 && x <= 111355 || x >= 119552 && x <= 119638 || x >= 119648 && x <= 119670 || x === 126980 || x === 127183 || x === 127374 || x >= 127377 && x <= 127386 || x >= 127488 && x <= 127490 || x >= 127504 && x <= 127547 || x >= 127552 && x <= 127560 || x === 127568 || x === 127569 || x >= 127584 && x <= 127589 || x >= 127744 && x <= 127776 || x >= 127789 && x <= 127797 || x >= 127799 && x <= 127868 || x >= 127870 && x <= 127891 || x >= 127904 && x <= 127946 || x >= 127951 && x <= 127955 || x >= 127968 && x <= 127984 || x === 127988 || x >= 127992 && x <= 128062 || x === 128064 || x >= 128066 && x <= 128252 || x >= 128255 && x <= 128317 || x >= 128331 && x <= 128334 || x >= 128336 && x <= 128359 || x === 128378 || x === 128405 || x === 128406 || x === 128420 || x >= 128507 && x <= 128591 || x >= 128640 && x <= 128709 || x === 128716 || x >= 128720 && x <= 128722 || x >= 128725 && x <= 128727 || x >= 128732 && x <= 128735 || x === 128747 || x === 128748 || x >= 128756 && x <= 128764 || x >= 128992 && x <= 129003 || x === 129008 || x >= 129292 && x <= 129338 || x >= 129340 && x <= 129349 || x >= 129351 && x <= 129535 || x >= 129648 && x <= 129660 || x >= 129664 && x <= 129673 || x >= 129679 && x <= 129734 || x >= 129742 && x <= 129756 || x >= 129759 && x <= 129769 || x >= 129776 && x <= 129784 || x >= 131072 && x <= 196605 || x >= 196608 && x <= 262141;
}
function validate(codePoint) {
	if (!Number.isSafeInteger(codePoint)) throw new TypeError(`Expected a code point, got \`${typeof codePoint}\`.`);
}
function eastAsianWidth(codePoint, { ambiguousAsWide = false } = {}) {
	return validate(codePoint), isFullWidth(codePoint) || isWide(codePoint) || ambiguousAsWide && isAmbiguous(codePoint) ? 2 : 1;
}
var require_emoji_regex = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = () => {
		return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
	};
})), import_emoji_regex = /* @__PURE__ */ __toESM(require_emoji_regex(), 1);
const segmenter = new Intl.Segmenter(), defaultIgnorableCodePointRegex = /^\p{Default_Ignorable_Code_Point}$/u;
function stringWidth(string, options = {}) {
	if (typeof string !== "string" || string.length === 0) return 0;
	const { ambiguousIsNarrow = true, countAnsiEscapeCodes = false } = options;
	if (!countAnsiEscapeCodes) string = stripAnsi(string);
	if (string.length === 0) return 0;
	let width = 0;
	const eastAsianWidthOptions = { ambiguousAsWide: !ambiguousIsNarrow };
	for (const { segment: character } of segmenter.segment(string)) {
		const codePoint = character.codePointAt(0);
		if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159 || codePoint >= 8203 && codePoint <= 8207 || codePoint === 65279 || codePoint >= 768 && codePoint <= 879 || codePoint >= 6832 && codePoint <= 6911 || codePoint >= 7616 && codePoint <= 7679 || codePoint >= 8400 && codePoint <= 8447 || codePoint >= 65056 && codePoint <= 65071 || codePoint >= 55296 && codePoint <= 57343 || codePoint >= 65024 && codePoint <= 65039 || defaultIgnorableCodePointRegex.test(character)) continue;
		if ((0, import_emoji_regex.default)().test(character)) {
			width += 2;
			continue;
		}
		width += eastAsianWidth(codePoint, eastAsianWidthOptions);
	}
	return width;
}
var ResponsiveTable = class {
	head;
	rows = [];
	colAligns;
	style;
	dateFormatter;
	compactHead;
	compactColAligns;
	compactThreshold;
	compactMode = false;
	constructor(options) {
		this.head = options.head, this.colAligns = options.colAligns ?? Array.from({ length: this.head.length }, () => "left"), this.style = options.style, this.dateFormatter = options.dateFormatter, this.compactHead = options.compactHead, this.compactColAligns = options.compactColAligns, this.compactThreshold = options.compactThreshold ?? 100;
	}
	push(row) {
		this.rows.push(row);
	}
	filterRowToCompact(row, compactIndices) {
		return compactIndices.map((index) => row[index] ?? "");
	}
	getCurrentTableConfig() {
		return this.compactMode && this.compactHead != null && this.compactColAligns != null ? {
			head: this.compactHead,
			colAligns: this.compactColAligns
		} : {
			head: this.head,
			colAligns: this.colAligns
		};
	}
	getCompactIndices() {
		return this.compactHead == null || !this.compactMode ? Array.from({ length: this.head.length }, (_, i) => i) : this.compactHead.map((compactHeader) => {
			const index = this.head.indexOf(compactHeader);
			return index < 0 ? (console.warn(`Warning: Compact header "${compactHeader}" not found in table headers [${this.head.join(", ")}]. Using first column as fallback.`), 0) : index;
		});
	}
	isCompactMode() {
		return this.compactMode;
	}
	toString() {
		const terminalWidth = Number.parseInt(process$1.env.COLUMNS ?? "", 10) || process$1.stdout.columns || 120;
		this.compactMode = terminalWidth < this.compactThreshold && this.compactHead != null;
		const { head, colAligns } = this.getCurrentTableConfig(), compactIndices = this.getCompactIndices(), dataRows = this.rows.filter((row) => !this.isSeparatorRow(row)), processedDataRows = this.compactMode ? dataRows.map((row) => this.filterRowToCompact(row, compactIndices)) : dataRows, allRows = [head.map(String), ...processedDataRows.map((row) => row.map((cell) => {
			return typeof cell === "object" && cell != null && "content" in cell ? String(cell.content) : String(cell ?? "");
		}))], contentWidths = head.map((_, colIndex) => {
			const maxLength = Math.max(...allRows.map((row) => stringWidth(String(row[colIndex] ?? ""))));
			return maxLength;
		}), numColumns = head.length, tableOverhead = 3 * numColumns + 1, availableWidth = terminalWidth - tableOverhead, columnWidths = contentWidths.map((width, index) => {
			const align = colAligns[index];
			return align === "right" ? Math.max(width + 3, 11) : index === 1 ? Math.max(width + 2, 15) : Math.max(width + 2, 10);
		}), totalRequiredWidth = columnWidths.reduce((sum, width) => sum + width, 0) + tableOverhead;
		if (totalRequiredWidth > terminalWidth) {
			const scaleFactor = availableWidth / columnWidths.reduce((sum, width) => sum + width, 0), adjustedWidths = columnWidths.map((width, index) => {
				const align = colAligns[index];
				let adjustedWidth = Math.floor(width * scaleFactor);
				if (align === "right") adjustedWidth = Math.max(adjustedWidth, 10);
				else if (index === 0) adjustedWidth = Math.max(adjustedWidth, 10);
				else if (index === 1) adjustedWidth = Math.max(adjustedWidth, 12);
				else adjustedWidth = Math.max(adjustedWidth, 8);
				return adjustedWidth;
			}), table = new import_cli_table3.default({
				head,
				style: this.style,
				colAligns,
				colWidths: adjustedWidths,
				wordWrap: true,
				wrapOnWordBoundary: true
			});
			for (const row of this.rows) if (this.isSeparatorRow(row)) continue;
			else {
				let processedRow = row.map((cell, index) => {
					return index === 0 && this.dateFormatter != null && typeof cell === "string" && this.isDateString(cell) ? this.dateFormatter(cell) : cell;
				});
				if (this.compactMode) processedRow = this.filterRowToCompact(processedRow, compactIndices);
				table.push(processedRow);
			}
			return table.toString();
		} else {
			const table = new import_cli_table3.default({
				head,
				style: this.style,
				colAligns,
				colWidths: columnWidths,
				wordWrap: true,
				wrapOnWordBoundary: true
			});
			for (const row of this.rows) if (this.isSeparatorRow(row)) continue;
			else {
				const processedRow = this.compactMode ? this.filterRowToCompact(row, compactIndices) : row;
				table.push(processedRow);
			}
			return table.toString();
		}
	}
	isSeparatorRow(row) {
		return row.every((cell) => {
			return typeof cell === "object" && cell != null && "content" in cell ? cell.content === "" || /^+$/.test(cell.content) : typeof cell === "string" && (cell === "" || /^+$/.test(cell));
		});
	}
	isDateString(text) {
		return /^\d{4}-\d{2}-\d{2}$/.test(text);
	}
};
function formatNumber(num) {
	return num.toLocaleString("en-US");
}
function formatCurrency(amount) {
	return `$${amount.toFixed(2)}`;
}
function formatModelName(modelName) {
	const match = modelName.match(/claude-(\w+)-(\d+)-\d+/);
	return match == null ? modelName : `${match[1]}-${match[2]}`;
}
function formatModelsDisplay(models) {
	const uniqueModels = uniq(models.map(formatModelName));
	return uniqueModels.sort().join(", ");
}
function formatModelsDisplayMultiline(models) {
	const uniqueModels = uniq(models.map(formatModelName));
	return uniqueModels.sort().map((model) => `- ${model}`).join("\n");
}
function pushBreakdownRows(table, breakdowns, extraColumns = 1, trailingColumns = 0) {
	for (const breakdown of breakdowns) {
		const row = [`   ${formatModelName(breakdown.modelName)}`];
		for (let i = 0; i < extraColumns; i++) row.push("");
		const totalTokens = breakdown.inputTokens + breakdown.outputTokens + breakdown.cacheCreationTokens + breakdown.cacheReadTokens;
		row.push(import_picocolors$8.default.gray(formatNumber(breakdown.inputTokens)), import_picocolors$8.default.gray(formatNumber(breakdown.outputTokens)), import_picocolors$8.default.gray(formatNumber(breakdown.cacheCreationTokens)), import_picocolors$8.default.gray(formatNumber(breakdown.cacheReadTokens)), import_picocolors$8.default.gray(formatNumber(totalTokens)), import_picocolors$8.default.gray(formatCurrency(breakdown.cost)));
		for (let i = 0; i < trailingColumns; i++) row.push("");
		table.push(row);
	}
}
var LiveMonitor = class {
	config;
	fetcher = null;
	lastFileTimestamps = /* @__PURE__ */ new Map();
	processedHashes = /* @__PURE__ */ new Set();
	allEntries = [];
	constructor(config) {
		if (this.config = config, config.mode !== "display") this.fetcher = new PricingFetcher();
	}
	[Symbol.dispose]() {
		this.fetcher?.[Symbol.dispose]();
	}
	async getActiveBlock() {
		const results = await globUsageFiles(this.config.claudePaths), allFiles = results.map((r) => r.file);
		if (allFiles.length === 0) return null;
		const filesToRead = [];
		for (const file of allFiles) {
			const timestamp = await getEarliestTimestamp(file), lastTimestamp = this.lastFileTimestamps.get(file);
			if (timestamp != null && (lastTimestamp == null || timestamp.getTime() > lastTimestamp)) filesToRead.push(file), this.lastFileTimestamps.set(file, timestamp.getTime());
		}
		if (filesToRead.length > 0) {
			const sortedFiles = await sortFilesByTimestamp(filesToRead);
			for (const file of sortedFiles) {
				const content = await readFile(file, "utf-8").catch(() => {
					return "";
				}), lines = content.trim().split("\n").filter((line) => line.length > 0);
				for (const line of lines) try {
					const parsed = JSON.parse(line), result = usageDataSchema.safeParse(parsed);
					if (!result.success) continue;
					const data = result.data, uniqueHash = createUniqueHash(data);
					if (uniqueHash != null && this.processedHashes.has(uniqueHash)) continue;
					if (uniqueHash != null) this.processedHashes.add(uniqueHash);
					const costUSD = await (this.config.mode === "display" ? Promise.resolve(data.costUSD ?? 0) : calculateCostForEntry(data, this.config.mode, this.fetcher)), usageLimitResetTime = getUsageLimitResetTime(data);
					this.allEntries.push({
						timestamp: new Date(data.timestamp),
						usage: {
							inputTokens: data.message.usage.input_tokens ?? 0,
							outputTokens: data.message.usage.output_tokens ?? 0,
							cacheCreationInputTokens: data.message.usage.cache_creation_input_tokens ?? 0,
							cacheReadInputTokens: data.message.usage.cache_read_input_tokens ?? 0
						},
						costUSD,
						model: data.message.model ?? "<synthetic>",
						version: data.version,
						usageLimitResetTime: usageLimitResetTime ?? void 0
					});
				} catch {}
			}
		}
		const blocks = identifySessionBlocks(this.allEntries, this.config.sessionDurationHours), sortedBlocks = this.config.order === "asc" ? blocks : blocks.reverse();
		return sortedBlocks.find((block) => block.isActive) ?? null;
	}
	clearCache() {
		this.lastFileTimestamps.clear(), this.processedHashes.clear(), this.allEntries = [];
	}
};
function delay(ms, options = {}) {
	const { signal, persistent = true } = options;
	return signal?.aborted ? Promise.reject(signal.reason) : new Promise((resolve, reject) => {
		const abort = () => {
			clearTimeout(i), reject(signal?.reason);
		}, done = () => {
			signal?.removeEventListener("abort", abort), resolve();
		}, i = setTimeout(done, ms);
		if (signal?.addEventListener("abort", abort, { once: true }), persistent === false) try {
			Deno.unrefTimer(i);
		} catch (error) {
			if (!(error instanceof ReferenceError)) throw error;
			console.error("`persistent` option is only available in Deno");
		}
	});
}
const isBrowser = globalThis.window?.document !== void 0, isNode = globalThis.process?.versions?.node !== void 0, isBun = globalThis.process?.versions?.bun !== void 0, isDeno = globalThis.Deno?.version?.deno !== void 0, isElectron = globalThis.process?.versions?.electron !== void 0, isJsDom = globalThis.navigator?.userAgent?.includes("jsdom") === true, isWebWorker = typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope, isDedicatedWorker = typeof DedicatedWorkerGlobalScope !== "undefined" && globalThis instanceof DedicatedWorkerGlobalScope, isSharedWorker = typeof SharedWorkerGlobalScope !== "undefined" && globalThis instanceof SharedWorkerGlobalScope, isServiceWorker = typeof ServiceWorkerGlobalScope !== "undefined" && globalThis instanceof ServiceWorkerGlobalScope, platform = globalThis.navigator?.userAgentData?.platform, isMacOs = platform === "macOS" || globalThis.navigator?.platform === "MacIntel" || globalThis.navigator?.userAgent?.includes(" Mac ") === true || globalThis.process?.platform === "darwin", isWindows$1 = platform === "Windows" || globalThis.navigator?.platform === "Win32" || globalThis.process?.platform === "win32", isLinux = platform === "Linux" || globalThis.navigator?.platform?.startsWith("Linux") === true || globalThis.navigator?.userAgent?.includes(" Linux ") === true || globalThis.process?.platform === "linux", isIos = platform === "iOS" || globalThis.navigator?.platform === "MacIntel" && globalThis.navigator?.maxTouchPoints > 1 || /iPad|iPhone|iPod/.test(globalThis.navigator?.platform), isAndroid = platform === "Android" || globalThis.navigator?.platform === "Android" || globalThis.navigator?.userAgent?.includes(" Android ") === true || globalThis.process?.platform === "android", ESC = "\x1B[", SEP = ";", isTerminalApp = !isBrowser && process$1.env.TERM_PROGRAM === "Apple_Terminal", isWindows = !isBrowser && process$1.platform === "win32", cwdFunction = isBrowser ? () => {
	throw new Error("`process.cwd()` only works in Node.js, not the browser.");
} : process$1.cwd, cursorTo = (x, y) => {
	if (typeof x !== "number") throw new TypeError("The `x` argument is required");
	return typeof y === "number" ? ESC + (y + 1) + SEP + (x + 1) + "H" : ESC + (x + 1) + "G";
}, cursorForward = (count = 1) => ESC + count + "C", cursorLeft = ESC + "G", cursorSavePosition = isTerminalApp ? "\x1B7" : ESC + "s", cursorRestorePosition = isTerminalApp ? "\x1B8" : ESC + "u", cursorGetPosition = ESC + "6n", cursorNextLine = ESC + "E", cursorPrevLine = ESC + "F", cursorHide = ESC + "?25l", cursorShow = ESC + "?25h", eraseEndLine = ESC + "K", eraseStartLine = ESC + "1K", eraseLine = ESC + "2K", eraseDown = ESC + "J", eraseUp = ESC + "1J", eraseScreen = ESC + "2J", scrollUp = ESC + "S", scrollDown = ESC + "T", clearScreen = "\x1Bc", clearTerminal = isWindows ? `${eraseScreen}${ESC}0f` : `${eraseScreen}${ESC}3J${ESC}H`, enterAlternativeScreen = ESC + "?1049h", exitAlternativeScreen = ESC + "?1049l", toZeroIfInfinity = (value) => Number.isFinite(value) ? value : 0;
function parseNumber(milliseconds) {
	return {
		days: Math.trunc(milliseconds / 864e5),
		hours: Math.trunc(milliseconds / 36e5 % 24),
		minutes: Math.trunc(milliseconds / 6e4 % 60),
		seconds: Math.trunc(milliseconds / 1e3 % 60),
		milliseconds: Math.trunc(milliseconds % 1e3),
		microseconds: Math.trunc(toZeroIfInfinity(milliseconds * 1e3) % 1e3),
		nanoseconds: Math.trunc(toZeroIfInfinity(milliseconds * 1e6) % 1e3)
	};
}
function parseBigint(milliseconds) {
	return {
		days: milliseconds / 86400000n,
		hours: milliseconds / 3600000n % 24n,
		minutes: milliseconds / 60000n % 60n,
		seconds: milliseconds / 1000n % 60n,
		milliseconds: milliseconds % 1000n,
		microseconds: 0n,
		nanoseconds: 0n
	};
}
function parseMilliseconds(milliseconds) {
	switch (typeof milliseconds) {
		case "number":
			if (Number.isFinite(milliseconds)) return parseNumber(milliseconds);
			break;
		case "bigint": return parseBigint(milliseconds);
	}
	throw new TypeError("Expected a finite number or bigint");
}
const isZero = (value) => value === 0 || value === 0n, pluralize = (word, count) => count === 1 || count === 1n ? word : `${word}s`, SECOND_ROUNDING_EPSILON = 1e-7, ONE_DAY_IN_MILLISECONDS = 24n * 60n * 60n * 1000n;
function prettyMilliseconds(milliseconds, options) {
	const isBigInt = typeof milliseconds === "bigint";
	if (!isBigInt && !Number.isFinite(milliseconds)) throw new TypeError("Expected a finite number or bigint");
	options = { ...options };
	const sign = milliseconds < 0 ? "-" : "";
	if (milliseconds = milliseconds < 0 ? -milliseconds : milliseconds, options.colonNotation) options.compact = false, options.formatSubMilliseconds = false, options.separateMilliseconds = false, options.verbose = false;
	if (options.compact) options.unitCount = 1, options.secondsDecimalDigits = 0, options.millisecondsDecimalDigits = 0;
	let result = [];
	const floorDecimals = (value, decimalDigits) => {
		const flooredInterimValue = Math.floor(value * 10 ** decimalDigits + SECOND_ROUNDING_EPSILON), flooredValue = Math.round(flooredInterimValue) / 10 ** decimalDigits;
		return flooredValue.toFixed(decimalDigits);
	}, add = (value, long, short, valueString) => {
		if (!((result.length === 0 || !options.colonNotation) && isZero(value) && !(options.colonNotation && short === "m"))) {
			if (valueString ??= String(value), options.colonNotation) {
				const wholeDigits = valueString.includes(".") ? valueString.split(".")[0].length : valueString.length, minLength = result.length > 0 ? 2 : 1;
				valueString = "0".repeat(Math.max(0, minLength - wholeDigits)) + valueString;
			} else valueString += options.verbose ? " " + pluralize(long, value) : short;
			result.push(valueString);
		}
	}, parsed = parseMilliseconds(milliseconds), days = BigInt(parsed.days);
	if (options.hideYearAndDays) add(BigInt(days) * 24n + BigInt(parsed.hours), "hour", "h");
	else {
		if (options.hideYear) add(days, "day", "d");
		else add(days / 365n, "year", "y"), add(days % 365n, "day", "d");
		add(Number(parsed.hours), "hour", "h");
	}
	if (add(Number(parsed.minutes), "minute", "m"), !options.hideSeconds) if (options.separateMilliseconds || options.formatSubMilliseconds || !options.colonNotation && milliseconds < 1e3) {
		const seconds = Number(parsed.seconds), milliseconds$1 = Number(parsed.milliseconds), microseconds = Number(parsed.microseconds), nanoseconds = Number(parsed.nanoseconds);
		if (add(seconds, "second", "s"), options.formatSubMilliseconds) add(milliseconds$1, "millisecond", "ms"), add(microseconds, "microsecond", "s"), add(nanoseconds, "nanosecond", "ns");
		else {
			const millisecondsAndBelow = milliseconds$1 + microseconds / 1e3 + nanoseconds / 1e6, millisecondsDecimalDigits = typeof options.millisecondsDecimalDigits === "number" ? options.millisecondsDecimalDigits : 0, roundedMilliseconds = millisecondsAndBelow >= 1 ? Math.round(millisecondsAndBelow) : Math.ceil(millisecondsAndBelow), millisecondsString = millisecondsDecimalDigits ? millisecondsAndBelow.toFixed(millisecondsDecimalDigits) : roundedMilliseconds;
			add(Number.parseFloat(millisecondsString), "millisecond", "ms", millisecondsString);
		}
	} else {
		const seconds = (isBigInt ? Number(milliseconds % ONE_DAY_IN_MILLISECONDS) : milliseconds) / 1e3 % 60, secondsDecimalDigits = typeof options.secondsDecimalDigits === "number" ? options.secondsDecimalDigits : 1, secondsFixed = floorDecimals(seconds, secondsDecimalDigits), secondsString = options.keepDecimalsOnWholeSeconds ? secondsFixed : secondsFixed.replace(/\.0+$/, "");
		add(Number.parseFloat(secondsString), "second", "s", secondsString);
	}
	if (result.length === 0) return sign + "0" + (options.verbose ? " milliseconds" : "ms");
	const separator = options.colonNotation ? ":" : " ";
	if (typeof options.unitCount === "number") result = result.slice(0, Math.max(options.unitCount, 1));
	return sign + result.join(separator);
}
const SYNC_START = "\x1B[?2026h", SYNC_END = "\x1B[?2026l", DISABLE_LINE_WRAP = "\x1B[?7l", ENABLE_LINE_WRAP = "\x1B[?7h", ANSI_RESET = "\x1B[0m";
var TerminalManager = class {
	stream;
	cursorHidden = false;
	buffer = [];
	useBuffering = false;
	alternateScreenActive = false;
	syncMode = false;
	constructor(stream = process$1.stdout) {
		this.stream = stream;
	}
	hideCursor() {
		if (!this.cursorHidden && this.stream.isTTY) this.stream.write(cursorHide), this.cursorHidden = true;
	}
	showCursor() {
		if (this.cursorHidden && this.stream.isTTY) this.stream.write(cursorShow), this.cursorHidden = false;
	}
	clearScreen() {
		if (this.stream.isTTY) this.stream.write(clearScreen), this.stream.write(cursorTo(0, 0));
	}
	write(text) {
		if (this.useBuffering) this.buffer.push(text);
		else this.stream.write(text);
	}
	startBuffering() {
		this.useBuffering = true, this.buffer = [];
	}
	flush() {
		if (this.useBuffering && this.buffer.length > 0) {
			if (this.syncMode && this.stream.isTTY) this.stream.write(SYNC_START + this.buffer.join("") + SYNC_END);
			else this.stream.write(this.buffer.join(""));
			this.buffer = [];
		}
		this.useBuffering = false;
	}
	enterAlternateScreen() {
		if (!this.alternateScreenActive && this.stream.isTTY) this.stream.write(enterAlternativeScreen), this.stream.write(DISABLE_LINE_WRAP), this.alternateScreenActive = true;
	}
	exitAlternateScreen() {
		if (this.alternateScreenActive && this.stream.isTTY) this.stream.write(ENABLE_LINE_WRAP), this.stream.write(exitAlternativeScreen), this.alternateScreenActive = false;
	}
	enableSyncMode() {
		this.syncMode = true;
	}
	disableSyncMode() {
		this.syncMode = false;
	}
	get width() {
		return this.stream.columns || 80;
	}
	get height() {
		return this.stream.rows || 24;
	}
	get isTTY() {
		return this.stream.isTTY ?? false;
	}
	cleanup() {
		this.showCursor(), this.exitAlternateScreen(), this.disableSyncMode();
	}
};
function createProgressBar(value, max, width, options = {}) {
	const { showPercentage = true, showValues = false, fillChar = "", emptyChar = "", leftBracket = "[", rightBracket = "]", colors: colors$2 = {} } = options, percentage = max > 0 ? Math.min(100, value / max * 100) : 0, fillWidth = Math.round(percentage / 100 * width), emptyWidth = width - fillWidth;
	let color = "";
	if (colors$2.critical != null && percentage >= 90) color = colors$2.critical;
	else if (colors$2.high != null && percentage >= 80) color = colors$2.high;
	else if (colors$2.medium != null && percentage >= 50) color = colors$2.medium;
	else if (colors$2.low != null) color = colors$2.low;
	let bar = leftBracket;
	if (color !== "") bar += color;
	if (bar += fillChar.repeat(fillWidth), bar += emptyChar.repeat(emptyWidth), color !== "") bar += ANSI_RESET;
	if (bar += rightBracket, showPercentage) bar += ` ${percentage.toFixed(1)}%`;
	if (showValues) bar += ` (${value}/${max})`;
	return bar;
}
function centerText(text, width) {
	const textLength = stringWidth(text);
	if (textLength >= width) return text;
	const leftPadding = Math.floor((width - textLength) / 2), rightPadding = width - textLength - leftPadding;
	return " ".repeat(leftPadding) + text + " ".repeat(rightPadding);
}
const SAVE_CURSOR = "\x1B7", RESTORE_CURSOR = "\x1B8";
function drawEmoji(emoji) {
	return `${SAVE_CURSOR}${emoji}${RESTORE_CURSOR}${cursorForward(stringWidth(emoji))}`;
}
var import_picocolors$7 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
function getRateIndicator(burnRate) {
	if (burnRate == null) return "";
	switch (true) {
		case burnRate.tokensPerMinuteForIndicator > BURN_RATE_THRESHOLDS.HIGH: return import_picocolors$7.default.red(`${drawEmoji("")} HIGH`);
		case burnRate.tokensPerMinuteForIndicator > BURN_RATE_THRESHOLDS.MODERATE: return import_picocolors$7.default.yellow(`${drawEmoji("")} MODERATE`);
		default: return import_picocolors$7.default.green(`${drawEmoji("")} NORMAL`);
	}
}
async function delayWithAbort(ms, signal) {
	await delay(ms, { signal });
}
async function renderWaitingState(terminal, config, signal) {
	terminal.startBuffering(), terminal.write(cursorTo(0, 0)), terminal.write(eraseDown), terminal.write(import_picocolors$7.default.yellow("No active session block found. Waiting...\n")), terminal.write(cursorHide), terminal.flush(), await delayWithAbort(config.refreshInterval, signal);
}
function renderActiveBlock(terminal, activeBlock, config) {
	terminal.startBuffering(), terminal.write(cursorTo(0, 0)), terminal.write(eraseDown), renderLiveDisplay(terminal, activeBlock, config), terminal.write(cursorHide), terminal.flush();
}
function formatTokensShort(num) {
	return num >= 1e3 ? `${(num / 1e3).toFixed(1)}k` : num.toString();
}
function renderLiveDisplay(terminal, block, config) {
	const width = terminal.width, now = /* @__PURE__ */ new Date(), totalTokens = getTotalTokens(block.tokenCounts), elapsed = (now.getTime() - block.startTime.getTime()) / (1e3 * 60), remaining = (block.endTime.getTime() - now.getTime()) / (1e3 * 60), formatTokenDisplay = (tokens, useShort) => {
		return useShort ? formatTokensShort(tokens) : formatNumber(tokens);
	};
	if (width < 60) {
		renderCompactLiveDisplay(terminal, block, config, totalTokens, elapsed, remaining);
		return;
	}
	const boxWidth = Math.min(120, width - 2), boxMargin = Math.floor((width - boxWidth) / 2), marginStr = " ".repeat(boxMargin), sessionDuration = elapsed + remaining, sessionPercent = elapsed / sessionDuration * 100, sessionRightText = `${sessionPercent.toFixed(1).padStart(6)}%`, tokenPercent = config.tokenLimit != null && config.tokenLimit > 0 ? totalTokens / config.tokenLimit * 100 : 0, usageRightText = config.tokenLimit != null && config.tokenLimit > 0 ? `${tokenPercent.toFixed(1).padStart(6)}% (${formatTokensShort(totalTokens)}/${formatTokensShort(config.tokenLimit)})` : `(${formatTokensShort(totalTokens)} tokens)`, projection = projectBlockUsage(block), projectedPercent = projection != null && config.tokenLimit != null && config.tokenLimit > 0 ? projection.totalTokens / config.tokenLimit * 100 : 0, projectionRightText = projection != null ? config.tokenLimit != null && config.tokenLimit > 0 ? `${projectedPercent.toFixed(1).padStart(6)}% (${formatTokensShort(projection.totalTokens)}/${formatTokensShort(config.tokenLimit)})` : `(${formatTokensShort(projection.totalTokens)} tokens)` : "", maxRightTextWidth = Math.max(stringWidth(sessionRightText), stringWidth(usageRightText), projection != null ? stringWidth(projectionRightText) : 0), labelWidth = 14, spacing = 4, boxPadding = 4, barWidth = boxWidth - labelWidth - maxRightTextWidth - spacing - boxPadding, sessionProgressBar = createProgressBar(elapsed, sessionDuration, barWidth, {
		showPercentage: false,
		fillChar: import_picocolors$7.default.cyan(""),
		emptyChar: import_picocolors$7.default.gray(""),
		leftBracket: "[",
		rightBracket: "]"
	}), startTime = block.startTime.toLocaleTimeString(void 0, {
		hour: "2-digit",
		minute: "2-digit",
		second: "2-digit",
		hour12: true
	}), endTime = block.endTime.toLocaleTimeString(void 0, {
		hour: "2-digit",
		minute: "2-digit",
		second: "2-digit",
		hour12: true
	}), detailsIndent = 3, detailsSpacing = 2, detailsAvailableWidth = boxWidth - 3 - detailsIndent;
	terminal.write(`${marginStr}${"".repeat(boxWidth - 2)}\n`), terminal.write(`${marginStr}${import_picocolors$7.default.bold(centerText("CLAUDE CODE - LIVE TOKEN USAGE MONITOR", boxWidth - 2))}\n`), terminal.write(`${marginStr}${"".repeat(boxWidth - 2)}\n`), terminal.write(`${marginStr}${" ".repeat(boxWidth - 2)}\n`);
	const sessionLabel = `${drawEmoji("")}${import_picocolors$7.default.bold(" SESSION")}`, sessionLabelWidth = stringWidth(sessionLabel), sessionBarStr = `${sessionLabel}${"".padEnd(Math.max(0, labelWidth - sessionLabelWidth))} ${sessionProgressBar} ${sessionRightText}`, sessionBarPadded = sessionBarStr + " ".repeat(Math.max(0, boxWidth - 3 - stringWidth(sessionBarStr)));
	terminal.write(`${marginStr} ${sessionBarPadded}\n`);
	const sessionCol1 = `${import_picocolors$7.default.gray("Started:")} ${startTime}`, sessionCol2 = `${import_picocolors$7.default.gray("Elapsed:")} ${prettyMilliseconds(elapsed * 60 * 1e3, { compact: true })}`, sessionCol3 = `${import_picocolors$7.default.gray("Remaining:")} ${prettyMilliseconds(remaining * 60 * 1e3, { compact: true })} (${endTime})`;
	let sessionDetails = `${" ".repeat(detailsIndent)}${sessionCol1}${" ".repeat(detailsSpacing)}${sessionCol2}${" ".repeat(detailsSpacing)}${sessionCol3}`;
	const sessionDetailsWidth = stringWidth(sessionCol1) + stringWidth(sessionCol2) + stringWidth(sessionCol3) + detailsSpacing * 2;
	if (sessionDetailsWidth > detailsAvailableWidth) sessionDetails = `${" ".repeat(detailsIndent)}${sessionCol1}${" ".repeat(detailsSpacing)}${sessionCol3}`;
	const sessionDetailsPadded = sessionDetails + " ".repeat(Math.max(0, boxWidth - 3 - stringWidth(sessionDetails)));
	let usageLimitResetTimePadded = null;
	if (block.usageLimitResetTime !== void 0 && now < block.usageLimitResetTime) {
		const resetTime = block.usageLimitResetTime?.toLocaleTimeString(void 0, {
			hour: "2-digit",
			minute: "2-digit",
			hour12: true
		}) ?? null, usageLimitResetTime = resetTime !== null ? import_picocolors$7.default.red(`${drawEmoji("")} USAGE LIMIT. RESET AT ${resetTime}`) : "";
		usageLimitResetTimePadded = resetTime !== null ? usageLimitResetTime + " ".repeat(Math.max(0, boxWidth - 3 - stringWidth(usageLimitResetTime))) : null;
	}
	if (terminal.write(`${marginStr} ${sessionDetailsPadded}\n`), usageLimitResetTimePadded !== null) terminal.write(`${marginStr} ${usageLimitResetTimePadded}\n`);
	terminal.write(`${marginStr}${" ".repeat(boxWidth - 2)}\n`), terminal.write(`${marginStr}${"".repeat(boxWidth - 2)}\n`), terminal.write(`${marginStr}${" ".repeat(boxWidth - 2)}\n`);
	let barColor = import_picocolors$7.default.green;
	if (tokenPercent > 100) barColor = import_picocolors$7.default.red;
	else if (tokenPercent > 80) barColor = import_picocolors$7.default.yellow;
	const usageBar = config.tokenLimit != null && config.tokenLimit > 0 ? createProgressBar(totalTokens, config.tokenLimit, barWidth, {
		showPercentage: false,
		fillChar: barColor(""),
		emptyChar: import_picocolors$7.default.gray(""),
		leftBracket: "[",
		rightBracket: "]"
	}) : `[${import_picocolors$7.default.green("".repeat(Math.floor(barWidth * .1)))}${import_picocolors$7.default.gray("".repeat(barWidth - Math.floor(barWidth * .1)))}]`, burnRate = calculateBurnRate(block), rateIndicator = getRateIndicator(burnRate), buildRateDisplay = (useShort) => {
		if (burnRate == null) return `${import_picocolors$7.default.bold("Burn Rate:")} N/A`;
		const rateValue = Math.round(burnRate.tokensPerMinute), formattedRate = useShort ? formatTokensShort(rateValue) : formatNumber(rateValue);
		return `${import_picocolors$7.default.bold("Burn Rate:")} ${formattedRate} token/min ${rateIndicator}`;
	}, usageLabel = `${drawEmoji("")}${import_picocolors$7.default.bold(" USAGE")}`, usageLabelWidth = stringWidth(usageLabel), usageBarStr = `${usageLabel}${"".padEnd(Math.max(0, labelWidth - usageLabelWidth))} ${usageBar} ${usageRightText}`;
	let rateDisplay = buildRateDisplay(false), usageCol1 = `${import_picocolors$7.default.gray("Tokens:")} ${formatTokenDisplay(totalTokens, false)} (${rateDisplay})`, usageCol2 = config.tokenLimit != null && config.tokenLimit > 0 ? `${import_picocolors$7.default.gray("Limit:")} ${formatTokenDisplay(config.tokenLimit, false)} tokens` : "";
	const usageCol3 = `${import_picocolors$7.default.gray("Cost:")} ${formatCurrency(block.costUSD)}`;
	let totalWidth = stringWidth(usageCol1);
	if (usageCol2.length > 0) totalWidth += detailsSpacing + stringWidth(usageCol2);
	totalWidth += detailsSpacing + stringWidth(usageCol3);
	let useTwoLineLayout = false;
	if (totalWidth > detailsAvailableWidth) {
		if (useTwoLineLayout = true, rateDisplay = buildRateDisplay(true), usageCol1 = `${import_picocolors$7.default.gray("Tokens:")} ${formatTokenDisplay(totalTokens, true)} (${rateDisplay})`, usageCol2.length > 0) usageCol2 = `${import_picocolors$7.default.gray("Limit:")} ${formatTokenDisplay(config.tokenLimit, true)} tokens`;
	}
	const usageBarPadded = usageBarStr + " ".repeat(Math.max(0, boxWidth - 3 - stringWidth(usageBarStr)));
	if (terminal.write(`${marginStr} ${usageBarPadded}\n`), useTwoLineLayout) {
		const usageDetailsLine1 = `${" ".repeat(detailsIndent)}${usageCol1}`, usageDetailsLine1Padded = usageDetailsLine1 + " ".repeat(Math.max(0, boxWidth - 3 - stringWidth(usageDetailsLine1)));
		terminal.write(`${marginStr} ${usageDetailsLine1Padded}\n`);
		let usageDetailsLine2;
		if (usageCol2.length > 0) usageDetailsLine2 = `${" ".repeat(detailsIndent)}${usageCol2}${" ".repeat(detailsSpacing)}${usageCol3}`;
		else usageDetailsLine2 = `${" ".repeat(detailsIndent)}${usageCol3}`;
		const usageDetailsLine2Padded = usageDetailsLine2 + " ".repeat(Math.max(0, boxWidth - 3 - stringWidth(usageDetailsLine2)));
		terminal.write(`${marginStr} ${usageDetailsLine2Padded}\n`);
	} else {
		let usageDetails;
		if (usageCol2.length > 0) usageDetails = `${" ".repeat(detailsIndent)}${usageCol1}${" ".repeat(detailsSpacing)}${usageCol2}${" ".repeat(detailsSpacing)}${usageCol3}`;
		else usageDetails = `${" ".repeat(detailsIndent)}${usageCol1}${" ".repeat(detailsSpacing)}${usageCol3}`;
		const usageDetailsPadded = usageDetails + " ".repeat(Math.max(0, boxWidth - 3 - stringWidth(usageDetails)));
		terminal.write(`${marginStr} ${usageDetailsPadded}\n`);
	}
	if (terminal.write(`${marginStr}${" ".repeat(boxWidth - 2)}\n`), terminal.write(`${marginStr}${"".repeat(boxWidth - 2)}\n`), terminal.write(`${marginStr}${" ".repeat(boxWidth - 2)}\n`), projection != null) {
		let projBarColor = import_picocolors$7.default.green;
		if (projectedPercent > 100) projBarColor = import_picocolors$7.default.red;
		else if (projectedPercent > 80) projBarColor = import_picocolors$7.default.yellow;
		const projectionBar = config.tokenLimit != null && config.tokenLimit > 0 ? createProgressBar(projection.totalTokens, config.tokenLimit, barWidth, {
			showPercentage: false,
			fillChar: projBarColor(""),
			emptyChar: import_picocolors$7.default.gray(""),
			leftBracket: "[",
			rightBracket: "]"
		}) : `[${import_picocolors$7.default.green("".repeat(Math.floor(barWidth * .15)))}${import_picocolors$7.default.gray("".repeat(barWidth - Math.floor(barWidth * .15)))}]`, limitStatus = config.tokenLimit != null && config.tokenLimit > 0 ? projectedPercent > 100 ? import_picocolors$7.default.red(`${drawEmoji("")} WILL EXCEED LIMIT`) : projectedPercent > 80 ? import_picocolors$7.default.yellow(`${drawEmoji("")} APPROACHING LIMIT`) : import_picocolors$7.default.green(`${drawEmoji("")} WITHIN LIMIT`) : import_picocolors$7.default.green(`${drawEmoji("")} ON TRACK`), projLabel = `${drawEmoji("")}${import_picocolors$7.default.bold(" PROJECTION")}`, projLabelWidth = stringWidth(projLabel), projBarStr = `${projLabel}${"".padEnd(Math.max(0, labelWidth - projLabelWidth))} ${projectionBar} ${projectionRightText}`, projBarPadded = projBarStr + " ".repeat(Math.max(0, boxWidth - 3 - stringWidth(projBarStr)));
		terminal.write(`${marginStr} ${projBarPadded}\n`);
		const projCol1 = `${import_picocolors$7.default.gray("Status:")} ${limitStatus}`;
		let projCol2 = `${import_picocolors$7.default.gray("Tokens:")} ${formatTokenDisplay(projection.totalTokens, false)}`;
		const projCol3 = `${import_picocolors$7.default.gray("Cost:")} ${formatCurrency(projection.totalCost)}`, projTotalWidth = stringWidth(projCol1) + stringWidth(projCol2) + stringWidth(projCol3) + detailsSpacing * 2;
		let projUseTwoLineLayout = false;
		if (projTotalWidth > detailsAvailableWidth) projUseTwoLineLayout = true, projCol2 = `${import_picocolors$7.default.gray("Tokens:")} ${formatTokenDisplay(projection.totalTokens, true)}`;
		if (projUseTwoLineLayout) {
			const projDetailsLine1 = `${" ".repeat(detailsIndent)}${projCol1}`, projDetailsLine1Padded = projDetailsLine1 + " ".repeat(Math.max(0, boxWidth - 3 - stringWidth(projDetailsLine1)));
			terminal.write(`${marginStr} ${projDetailsLine1Padded}\n`);
			const projDetailsLine2 = `${" ".repeat(detailsIndent)}${projCol2}${" ".repeat(detailsSpacing)}${projCol3}`, projDetailsLine2Padded = projDetailsLine2 + " ".repeat(Math.max(0, boxWidth - 3 - stringWidth(projDetailsLine2)));
			terminal.write(`${marginStr} ${projDetailsLine2Padded}\n`);
		} else {
			const projDetails = `${" ".repeat(detailsIndent)}${projCol1}${" ".repeat(detailsSpacing)}${projCol2}${" ".repeat(detailsSpacing)}${projCol3}`, projDetailsPadded = projDetails + " ".repeat(Math.max(0, boxWidth - 3 - stringWidth(projDetails)));
			terminal.write(`${marginStr} ${projDetailsPadded}\n`);
		}
		terminal.write(`${marginStr}${" ".repeat(boxWidth - 2)}\n`);
	}
	if (block.models.length > 0) {
		terminal.write(`${marginStr}${"".repeat(boxWidth - 2)}\n`);
		const modelsLine = `${drawEmoji("")}  Models: ${formatModelsDisplay(block.models)}`, modelsLinePadded = modelsLine + " ".repeat(Math.max(0, boxWidth - 3 - stringWidth(modelsLine)));
		terminal.write(`${marginStr} ${modelsLinePadded}\n`);
	}
	terminal.write(`${marginStr}${"".repeat(boxWidth - 2)}\n`);
	const refreshText = `${drawEmoji("")} Refreshing every ${config.refreshInterval / 1e3}s    Press Ctrl+C to stop`;
	terminal.write(`${marginStr}${import_picocolors$7.default.gray(centerText(refreshText, boxWidth - 2))}\n`), terminal.write(`${marginStr}${"".repeat(boxWidth - 2)}\n`);
}
function renderCompactLiveDisplay(terminal, block, config, totalTokens, elapsed, remaining) {
	const width = terminal.width;
	terminal.write(`${import_picocolors$7.default.bold(centerText("LIVE MONITOR", width))}\n`), terminal.write(`${"".repeat(width)}\n`);
	const sessionPercent = elapsed / (elapsed + remaining) * 100;
	if (terminal.write(`Session: ${sessionPercent.toFixed(1)}% (${Math.floor(elapsed / 60)}h ${Math.floor(elapsed % 60)}m)\n`), config.tokenLimit != null && config.tokenLimit > 0) {
		const tokenPercent = totalTokens / config.tokenLimit * 100, status = tokenPercent > 100 ? import_picocolors$7.default.red("OVER") : tokenPercent > 80 ? import_picocolors$7.default.yellow("WARN") : import_picocolors$7.default.green("OK");
		terminal.write(`Tokens: ${formatNumber(totalTokens)}/${formatNumber(config.tokenLimit)} ${status}\n`);
	} else terminal.write(`Tokens: ${formatNumber(totalTokens)}\n`);
	terminal.write(`Cost: ${formatCurrency(block.costUSD)}\n`);
	const burnRate = calculateBurnRate(block);
	if (burnRate != null) terminal.write(`Rate: ${formatNumber(burnRate.tokensPerMinute)}/min\n`);
	terminal.write(`${"".repeat(width)}\n`), terminal.write(import_picocolors$7.default.gray(`Refresh: ${config.refreshInterval / 1e3}s | Ctrl+C: stop\n`));
}
var import_picocolors$6 = /* @__PURE__ */ __toESM(require_picocolors(), 1), import_usingCtx = /* @__PURE__ */ __toESM(require_usingCtx(), 1);
async function startLiveMonitoring(config) {
	try {
		var _usingCtx = (0, import_usingCtx.default)();
		const terminal = new TerminalManager(), abortController = new AbortController();
		let lastRenderTime = 0;
		const cleanup = () => {
			if (abortController.abort(), terminal.cleanup(), terminal.clearScreen(), logger.info("Live monitoring stopped."), process$1.exitCode == null) process$1.exit(0);
		};
		process$1.on("SIGINT", cleanup), process$1.on("SIGTERM", cleanup), terminal.enterAlternateScreen(), terminal.enableSyncMode(), terminal.clearScreen(), terminal.hideCursor();
		const monitor = _usingCtx.u(new LiveMonitor({
			claudePaths: config.claudePaths,
			sessionDurationHours: config.sessionDurationHours,
			mode: config.mode,
			order: config.order
		})), monitoringResult = await try_({
			try: async () => {
				while (!abortController.signal.aborted) {
					const now = Date.now(), timeSinceLastRender = now - lastRenderTime;
					if (timeSinceLastRender < MIN_RENDER_INTERVAL_MS) {
						await delayWithAbort(MIN_RENDER_INTERVAL_MS - timeSinceLastRender, abortController.signal);
						continue;
					}
					const activeBlock = await monitor.getActiveBlock();
					if (monitor.clearCache(), activeBlock == null) {
						await renderWaitingState(terminal, config, abortController.signal);
						continue;
					}
					renderActiveBlock(terminal, activeBlock, config), lastRenderTime = Date.now();
					let resizeEventHandler;
					try {
						await Promise.race([delayWithAbort(config.refreshInterval, abortController.signal), new Promise((resolve) => {
							resizeEventHandler = resolve, process$1.stdout.once("resize", resolve);
						})]);
					} finally {
						if (resizeEventHandler != null) process$1.stdout.removeListener("resize", resizeEventHandler);
					}
				}
			},
			catch: (error) => error
		})();
		if (isFailure(monitoringResult)) {
			const error = monitoringResult.error;
			if ((error instanceof DOMException || error instanceof Error) && error.name === "AbortError") return;
			const errorMessage = error instanceof Error ? error.message : String(error);
			terminal.startBuffering(), terminal.clearScreen(), terminal.write(import_picocolors$6.default.red(`Error: ${errorMessage}\n`)), terminal.flush(), logger.error(`Live monitoring error: ${errorMessage}`), await delayWithAbort(config.refreshInterval, abortController.signal).catch(() => {});
		}
	} catch (_) {
		_usingCtx.e = _;
	} finally {
		_usingCtx.d();
	}
}
var import_picocolors$5 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
function formatBlockTime(block, compact = false, locale) {
	const start = compact ? block.startTime.toLocaleString(locale, {
		month: "2-digit",
		day: "2-digit",
		hour: "2-digit",
		minute: "2-digit"
	}) : block.startTime.toLocaleString(locale);
	if (block.isGap ?? false) {
		const end = compact ? block.endTime.toLocaleString(locale, {
			hour: "2-digit",
			minute: "2-digit"
		}) : block.endTime.toLocaleString(locale), duration$1 = Math.round((block.endTime.getTime() - block.startTime.getTime()) / (1e3 * 60 * 60));
		return compact ? `${start}-${end}\n(${duration$1}h gap)` : `${start} - ${end} (${duration$1}h gap)`;
	}
	const duration = block.actualEndTime != null ? Math.round((block.actualEndTime.getTime() - block.startTime.getTime()) / (1e3 * 60)) : 0;
	if (block.isActive) {
		const now = /* @__PURE__ */ new Date(), elapsed = Math.round((now.getTime() - block.startTime.getTime()) / (1e3 * 60)), remaining = Math.round((block.endTime.getTime() - now.getTime()) / (1e3 * 60)), elapsedHours = Math.floor(elapsed / 60), elapsedMins = elapsed % 60, remainingHours = Math.floor(remaining / 60), remainingMins = remaining % 60;
		return compact ? `${start}\n(${elapsedHours}h${elapsedMins}m/${remainingHours}h${remainingMins}m)` : `${start} (${elapsedHours}h ${elapsedMins}m elapsed, ${remainingHours}h ${remainingMins}m remaining)`;
	}
	const hours = Math.floor(duration / 60), mins = duration % 60;
	return compact ? hours > 0 ? `${start}\n(${hours}h${mins}m)` : `${start}\n(${mins}m)` : hours > 0 ? `${start} (${hours}h ${mins}m)` : `${start} (${mins}m)`;
}
function formatModels(models) {
	return models.length === 0 ? "-" : formatModelsDisplayMultiline(models);
}
function parseTokenLimit(value, maxFromAll) {
	if (value == null || value === "" || value === "max") return maxFromAll > 0 ? maxFromAll : void 0;
	const limit = Number.parseInt(value, 10);
	return Number.isNaN(limit) ? void 0 : limit;
}
const blocksCommand = define({
	name: "blocks",
	description: "Show usage report grouped by session billing blocks",
	args: {
		...sharedCommandConfig.args,
		active: {
			type: "boolean",
			short: "a",
			description: "Show only active block with projections",
			default: false
		},
		recent: {
			type: "boolean",
			short: "r",
			description: `Show blocks from last ${DEFAULT_RECENT_DAYS} days (including active)`,
			default: false
		},
		tokenLimit: {
			type: "string",
			short: "t",
			description: "Token limit for quota warnings (e.g., 500000 or \"max\")"
		},
		sessionLength: {
			type: "number",
			short: "n",
			description: `Session block duration in hours (default: ${DEFAULT_SESSION_DURATION_HOURS})`,
			default: DEFAULT_SESSION_DURATION_HOURS
		},
		live: {
			type: "boolean",
			description: "Live monitoring mode with real-time updates",
			default: false
		},
		refreshInterval: {
			type: "number",
			description: `Refresh interval in seconds for live mode (default: ${DEFAULT_REFRESH_INTERVAL_SECONDS})`,
			default: DEFAULT_REFRESH_INTERVAL_SECONDS
		}
	},
	toKebab: true,
	async run(ctx) {
		const useJson = ctx.values.json || ctx.values.jq != null;
		if (useJson) logger.level = 0;
		if (ctx.values.sessionLength <= 0) logger.error("Session length must be a positive number"), process$1.exit(1);
		let blocks = await loadSessionBlockData({
			since: ctx.values.since,
			until: ctx.values.until,
			mode: ctx.values.mode,
			order: ctx.values.order,
			offline: ctx.values.offline,
			sessionDurationHours: ctx.values.sessionLength,
			timezone: ctx.values.timezone,
			locale: ctx.values.locale
		});
		if (blocks.length === 0) {
			if (useJson) log(JSON.stringify({ blocks: [] }));
			else logger.warn("No Claude usage data found.");
			process$1.exit(0);
		}
		let maxTokensFromAll = 0;
		if (ctx.values.tokenLimit === "max" || ctx.values.tokenLimit == null || ctx.values.tokenLimit === "") {
			for (const block of blocks) if (!(block.isGap ?? false) && !block.isActive) {
				const blockTokens = getTotalTokens(block.tokenCounts);
				if (blockTokens > maxTokensFromAll) maxTokensFromAll = blockTokens;
			}
			if (!useJson && maxTokensFromAll > 0) logger.info(`Using max tokens from previous sessions: ${formatNumber(maxTokensFromAll)}`);
		}
		if (ctx.values.recent) blocks = filterRecentBlocks(blocks, DEFAULT_RECENT_DAYS);
		if (ctx.values.active) {
			if (blocks = blocks.filter((block) => block.isActive), blocks.length === 0) {
				if (useJson) log(JSON.stringify({
					blocks: [],
					message: "No active block"
				}));
				else logger.info("No active session block found.");
				process$1.exit(0);
			}
		}
		if (ctx.values.live && !useJson) {
			if (!ctx.values.active) logger.info("Live mode automatically shows only active blocks.");
			let tokenLimitValue = ctx.values.tokenLimit;
			if (tokenLimitValue == null || tokenLimitValue === "") {
				if (tokenLimitValue = "max", maxTokensFromAll > 0) logger.info(`No token limit specified, using max from previous sessions: ${formatNumber(maxTokensFromAll)}`);
			}
			const refreshInterval = Math.max(MIN_REFRESH_INTERVAL_SECONDS, Math.min(MAX_REFRESH_INTERVAL_SECONDS, ctx.values.refreshInterval));
			if (refreshInterval !== ctx.values.refreshInterval) logger.warn(`Refresh interval adjusted to ${refreshInterval} seconds (valid range: ${MIN_REFRESH_INTERVAL_SECONDS}-${MAX_REFRESH_INTERVAL_SECONDS})`);
			const paths = getClaudePaths();
			if (paths.length === 0) throw logger.error("No valid Claude data directory found"), new Error("No valid Claude data directory found");
			await startLiveMonitoring({
				claudePaths: paths,
				tokenLimit: parseTokenLimit(tokenLimitValue, maxTokensFromAll),
				refreshInterval: refreshInterval * 1e3,
				sessionDurationHours: ctx.values.sessionLength,
				mode: ctx.values.mode,
				order: ctx.values.order
			});
			return;
		}
		if (useJson) {
			const jsonOutput = { blocks: blocks.map((block) => {
				const burnRate = block.isActive ? calculateBurnRate(block) : null, projection = block.isActive ? projectBlockUsage(block) : null;
				return {
					id: block.id,
					startTime: block.startTime.toISOString(),
					endTime: block.endTime.toISOString(),
					actualEndTime: block.actualEndTime?.toISOString() ?? null,
					isActive: block.isActive,
					isGap: block.isGap ?? false,
					entries: block.entries.length,
					tokenCounts: block.tokenCounts,
					totalTokens: getTotalTokens(block.tokenCounts),
					costUSD: block.costUSD,
					models: block.models,
					burnRate,
					projection,
					tokenLimitStatus: projection != null && ctx.values.tokenLimit != null ? (() => {
						const limit = parseTokenLimit(ctx.values.tokenLimit, maxTokensFromAll);
						return limit != null ? {
							limit,
							projectedUsage: projection.totalTokens,
							percentUsed: projection.totalTokens / limit * 100,
							status: projection.totalTokens > limit ? "exceeds" : projection.totalTokens > limit * BLOCKS_WARNING_THRESHOLD ? "warning" : "ok"
						} : void 0;
					})() : void 0,
					usageLimitResetTime: block.usageLimitResetTime
				};
			}) };
			if (ctx.values.jq != null) {
				const jqResult = await processWithJq(jsonOutput, ctx.values.jq);
				if (isFailure(jqResult)) logger.error(jqResult.error.message), process$1.exit(1);
				log(jqResult.value);
			} else log(JSON.stringify(jsonOutput, null, 2));
		} else if (ctx.values.active && blocks.length === 1) {
			const block = blocks[0];
			if (block == null) logger.warn("No active block found."), process$1.exit(0);
			const burnRate = calculateBurnRate(block), projection = projectBlockUsage(block);
			logger.box("Current Session Block Status");
			const now = /* @__PURE__ */ new Date(), elapsed = Math.round((now.getTime() - block.startTime.getTime()) / (1e3 * 60)), remaining = Math.round((block.endTime.getTime() - now.getTime()) / (1e3 * 60));
			if (log(`Block Started: ${import_picocolors$5.default.cyan(block.startTime.toLocaleString())} (${import_picocolors$5.default.yellow(`${Math.floor(elapsed / 60)}h ${elapsed % 60}m`)} ago)`), log(`Time Remaining: ${import_picocolors$5.default.green(`${Math.floor(remaining / 60)}h ${remaining % 60}m`)}\n`), log(import_picocolors$5.default.bold("Current Usage:")), log(`  Input Tokens:     ${formatNumber(block.tokenCounts.inputTokens)}`), log(`  Output Tokens:    ${formatNumber(block.tokenCounts.outputTokens)}`), log(`  Total Cost:       ${formatCurrency(block.costUSD)}\n`), burnRate != null) log(import_picocolors$5.default.bold("Burn Rate:")), log(`  Tokens/minute:    ${formatNumber(burnRate.tokensPerMinute)}`), log(`  Cost/hour:        ${formatCurrency(burnRate.costPerHour)}\n`);
			if (projection != null) {
				if (log(import_picocolors$5.default.bold("Projected Usage (if current rate continues):")), log(`  Total Tokens:     ${formatNumber(projection.totalTokens)}`), log(`  Total Cost:       ${formatCurrency(projection.totalCost)}\n`), ctx.values.tokenLimit != null) {
					const limit = parseTokenLimit(ctx.values.tokenLimit, maxTokensFromAll);
					if (limit != null && limit > 0) {
						const currentTokens = getTotalTokens(block.tokenCounts), remainingTokens = Math.max(0, limit - currentTokens), percentUsed = projection.totalTokens / limit * 100, status = percentUsed > 100 ? import_picocolors$5.default.red("EXCEEDS LIMIT") : percentUsed > BLOCKS_WARNING_THRESHOLD * 100 ? import_picocolors$5.default.yellow("WARNING") : import_picocolors$5.default.green("OK");
						log(import_picocolors$5.default.bold("Token Limit Status:")), log(`  Limit:            ${formatNumber(limit)} tokens`), log(`  Current Usage:    ${formatNumber(currentTokens)} (${(currentTokens / limit * 100).toFixed(1)}%)`), log(`  Remaining:        ${formatNumber(remainingTokens)} tokens`), log(`  Projected Usage:  ${percentUsed.toFixed(1)}% ${status}`);
					}
				}
			}
		} else {
			logger.box("Claude Code Token Usage Report - Session Blocks");
			const actualTokenLimit = parseTokenLimit(ctx.values.tokenLimit, maxTokensFromAll), tableHeaders = [
				"Block Start",
				"Duration/Status",
				"Models",
				"Tokens"
			], tableAligns = [
				"left",
				"left",
				"left",
				"right"
			];
			if (actualTokenLimit != null && actualTokenLimit > 0) tableHeaders.push("%"), tableAligns.push("right");
			tableHeaders.push("Cost"), tableAligns.push("right");
			const table = new ResponsiveTable({
				head: tableHeaders,
				style: { head: ["cyan"] },
				colAligns: tableAligns
			}), terminalWidth = process$1.stdout.columns || BLOCKS_DEFAULT_TERMINAL_WIDTH, useCompactFormat = terminalWidth < BLOCKS_COMPACT_WIDTH_THRESHOLD;
			for (const block of blocks) if (block.isGap ?? false) {
				const gapRow = [
					import_picocolors$5.default.gray(formatBlockTime(block, useCompactFormat, ctx.values.locale)),
					import_picocolors$5.default.gray("(inactive)"),
					import_picocolors$5.default.gray("-"),
					import_picocolors$5.default.gray("-")
				];
				if (actualTokenLimit != null && actualTokenLimit > 0) gapRow.push(import_picocolors$5.default.gray("-"));
				gapRow.push(import_picocolors$5.default.gray("-")), table.push(gapRow);
			} else {
				const totalTokens = getTotalTokens(block.tokenCounts), status = block.isActive ? import_picocolors$5.default.green("ACTIVE") : "", row = [
					formatBlockTime(block, useCompactFormat, ctx.values.locale),
					status,
					formatModels(block.models),
					formatNumber(totalTokens)
				];
				if (actualTokenLimit != null && actualTokenLimit > 0) {
					const percentage = totalTokens / actualTokenLimit * 100, percentText = `${percentage.toFixed(1)}%`;
					row.push(percentage > 100 ? import_picocolors$5.default.red(percentText) : percentText);
				}
				if (row.push(formatCurrency(block.costUSD)), table.push(row), block.isActive) {
					if (actualTokenLimit != null && actualTokenLimit > 0) {
						const currentTokens = getTotalTokens(block.tokenCounts), remainingTokens = Math.max(0, actualTokenLimit - currentTokens), remainingText = remainingTokens > 0 ? formatNumber(remainingTokens) : import_picocolors$5.default.red("0"), remainingPercent = (actualTokenLimit - currentTokens) / actualTokenLimit * 100, remainingPercentText = remainingPercent > 0 ? `${remainingPercent.toFixed(1)}%` : import_picocolors$5.default.red("0.0%"), remainingRow = [
							{
								content: import_picocolors$5.default.gray(`(assuming ${formatNumber(actualTokenLimit)} token limit)`),
								hAlign: "right"
							},
							import_picocolors$5.default.blue("REMAINING"),
							"",
							remainingText,
							remainingPercentText,
							""
						];
						table.push(remainingRow);
					}
					const projection = projectBlockUsage(block);
					if (projection != null) {
						const projectedTokens = formatNumber(projection.totalTokens), projectedText = actualTokenLimit != null && actualTokenLimit > 0 && projection.totalTokens > actualTokenLimit ? import_picocolors$5.default.red(projectedTokens) : projectedTokens, projectedRow = [
							{
								content: import_picocolors$5.default.gray("(assuming current burn rate)"),
								hAlign: "right"
							},
							import_picocolors$5.default.yellow("PROJECTED"),
							"",
							projectedText
						];
						if (actualTokenLimit != null && actualTokenLimit > 0) {
							const percentage = projection.totalTokens / actualTokenLimit * 100, percentText = `${percentage.toFixed(1)}%`;
							projectedRow.push(percentText);
						}
						projectedRow.push(formatCurrency(projection.totalCost)), table.push(projectedRow);
					}
				}
			}
			log(table.toString());
		}
	}
});
function groupByProject(dailyData) {
	const projects = {};
	for (const data of dailyData) {
		const projectName = data.project ?? "unknown";
		if (projects[projectName] == null) projects[projectName] = [];
		projects[projectName].push({
			date: data.date,
			inputTokens: data.inputTokens,
			outputTokens: data.outputTokens,
			cacheCreationTokens: data.cacheCreationTokens,
			cacheReadTokens: data.cacheReadTokens,
			totalTokens: getTotalTokens(data),
			totalCost: data.totalCost,
			modelsUsed: data.modelsUsed,
			modelBreakdowns: data.modelBreakdowns
		});
	}
	return projects;
}
function groupDataByProject(dailyData) {
	const projects = {};
	for (const data of dailyData) {
		const projectName = data.project ?? "unknown";
		if (projects[projectName] == null) projects[projectName] = [];
		projects[projectName].push(data);
	}
	return projects;
}
let aliasCache = null;
function getProjectAliases() {
	if (aliasCache !== null) return aliasCache;
	aliasCache = /* @__PURE__ */ new Map();
	const aliasEnv = (process$1.env[PROJECT_ALIASES_ENV] ?? "").trim();
	if (aliasEnv === "") return aliasCache;
	const pairs = aliasEnv.split(",").map((pair) => pair.trim()).filter((pair) => pair !== "");
	for (const pair of pairs) {
		const parts = pair.split("=").map((s) => s.trim()), rawName = parts[0], alias = parts[1];
		if (rawName != null && alias != null && rawName !== "" && alias !== "") aliasCache.set(rawName, alias);
	}
	return aliasCache;
}
function parseProjectName(projectName) {
	if (projectName === "unknown" || projectName === "") return "Unknown Project";
	let cleaned = projectName;
	if (cleaned.match(/^[A-Z]:\\Users\\|^\\Users\\/) != null) {
		const segments = cleaned.split("\\"), userIndex = segments.findIndex((seg) => seg === "Users");
		if (userIndex !== -1 && userIndex + 3 < segments.length) cleaned = segments.slice(userIndex + 3).join("-");
	}
	if (cleaned.startsWith("-Users-") || cleaned.startsWith("/Users/")) {
		const separator = cleaned.startsWith("-Users-") ? "-" : "/", segments = cleaned.split(separator).filter((s) => s.length > 0), userIndex = segments.findIndex((seg) => seg === "Users");
		if (userIndex !== -1 && userIndex + 3 < segments.length) cleaned = segments.slice(userIndex + 3).join("-");
	}
	if (cleaned === projectName) cleaned = projectName.replace(/^[/\\-]+|[/\\-]+$/g, "");
	if (cleaned.match(/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}/i) != null) {
		const parts = cleaned.split("-");
		if (parts.length >= 5) cleaned = parts.slice(-2).join("-");
	}
	if (cleaned.includes("--")) {
		const parts = cleaned.split("--");
		if (parts.length >= 2 && parts[0] != null) cleaned = parts[0];
	}
	if (cleaned.includes("-") && cleaned.length > 20) {
		const segments = cleaned.split("-"), meaningfulSegments = segments.filter((seg) => seg.length > 2 && seg.match(/^(?:dev|development|feat|feature|fix|bug|test|staging|prod|production|main|master|branch)$/i) == null);
		if (meaningfulSegments.length >= 2) {
			const lastSegments = meaningfulSegments.slice(-2);
			if (lastSegments.join("-").length >= 6) cleaned = lastSegments.join("-");
			else if (meaningfulSegments.length >= 3) cleaned = meaningfulSegments.slice(-3).join("-");
		}
	}
	return cleaned = cleaned.replace(/^[/\\-]+|[/\\-]+$/g, ""), cleaned !== "" ? cleaned : projectName !== "" ? projectName : "Unknown Project";
}
function formatProjectName(projectName) {
	const aliases = getProjectAliases();
	if (aliases.has(projectName)) return aliases.get(projectName);
	const parsed = parseProjectName(projectName);
	return aliases.has(parsed) ? aliases.get(parsed) : parsed;
}
var import_picocolors$4 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
const dailyCommand = define({
	name: "daily",
	description: "Show usage report grouped by date",
	...sharedCommandConfig,
	args: {
		...sharedCommandConfig.args,
		instances: {
			type: "boolean",
			short: "i",
			description: "Show usage breakdown by project/instance",
			default: false
		},
		project: {
			type: "string",
			short: "p",
			description: "Filter to specific project name"
		}
	},
	async run(ctx) {
		const useJson = ctx.values.json || ctx.values.jq != null;
		if (useJson) logger.level = 0;
		const dailyData = await loadDailyUsageData({
			since: ctx.values.since,
			until: ctx.values.until,
			mode: ctx.values.mode,
			order: ctx.values.order,
			offline: ctx.values.offline,
			groupByProject: ctx.values.instances,
			project: ctx.values.project,
			timezone: ctx.values.timezone,
			locale: ctx.values.locale
		});
		if (dailyData.length === 0) {
			if (useJson) log(JSON.stringify([]));
			else logger.warn("No Claude usage data found.");
			process$1.exit(0);
		}
		const totals = calculateTotals(dailyData);
		if (ctx.values.debug && !useJson) {
			const mismatchStats = await detectMismatches(void 0);
			printMismatchReport(mismatchStats, ctx.values.debugSamples);
		}
		if (useJson) {
			const jsonOutput = ctx.values.instances && dailyData.some((d) => d.project != null) ? {
				projects: groupByProject(dailyData),
				totals: createTotalsObject(totals)
			} : {
				daily: dailyData.map((data) => ({
					date: data.date,
					inputTokens: data.inputTokens,
					outputTokens: data.outputTokens,
					cacheCreationTokens: data.cacheCreationTokens,
					cacheReadTokens: data.cacheReadTokens,
					totalTokens: getTotalTokens(data),
					totalCost: data.totalCost,
					modelsUsed: data.modelsUsed,
					modelBreakdowns: data.modelBreakdowns,
					...data.project != null && { project: data.project }
				})),
				totals: createTotalsObject(totals)
			};
			if (ctx.values.jq != null) {
				const jqResult = await processWithJq(jsonOutput, ctx.values.jq);
				if (isFailure(jqResult)) logger.error(jqResult.error.message), process$1.exit(1);
				log(jqResult.value);
			} else log(JSON.stringify(jsonOutput, null, 2));
		} else {
			logger.box("Claude Code Token Usage Report - Daily");
			const table = new ResponsiveTable({
				head: [
					"Date",
					"Models",
					"Input",
					"Output",
					"Cache Create",
					"Cache Read",
					"Total Tokens",
					"Cost (USD)"
				],
				style: { head: ["cyan"] },
				colAligns: [
					"left",
					"left",
					"right",
					"right",
					"right",
					"right",
					"right",
					"right"
				],
				dateFormatter: (dateStr) => formatDateCompact(dateStr, ctx.values.timezone, ctx.values.locale),
				compactHead: [
					"Date",
					"Models",
					"Input",
					"Output",
					"Cost (USD)"
				],
				compactColAligns: [
					"left",
					"left",
					"right",
					"right",
					"right"
				],
				compactThreshold: 100
			});
			if (ctx.values.instances && dailyData.some((d) => d.project != null)) {
				const projectGroups = groupDataByProject(dailyData);
				let isFirstProject = true;
				for (const [projectName, projectData] of Object.entries(projectGroups)) {
					if (!isFirstProject) table.push([
						"",
						"",
						"",
						"",
						"",
						"",
						"",
						""
					]);
					table.push([
						import_picocolors$4.default.cyan(`Project: ${formatProjectName(projectName)}`),
						"",
						"",
						"",
						"",
						"",
						"",
						""
					]);
					for (const data of projectData) if (table.push([
						data.date,
						formatModelsDisplayMultiline(data.modelsUsed),
						formatNumber(data.inputTokens),
						formatNumber(data.outputTokens),
						formatNumber(data.cacheCreationTokens),
						formatNumber(data.cacheReadTokens),
						formatNumber(getTotalTokens(data)),
						formatCurrency(data.totalCost)
					]), ctx.values.breakdown) pushBreakdownRows(table, data.modelBreakdowns);
					isFirstProject = false;
				}
			} else for (const data of dailyData) if (table.push([
				data.date,
				formatModelsDisplayMultiline(data.modelsUsed),
				formatNumber(data.inputTokens),
				formatNumber(data.outputTokens),
				formatNumber(data.cacheCreationTokens),
				formatNumber(data.cacheReadTokens),
				formatNumber(getTotalTokens(data)),
				formatCurrency(data.totalCost)
			]), ctx.values.breakdown) pushBreakdownRows(table, data.modelBreakdowns);
			if (table.push([
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			]), table.push([
				import_picocolors$4.default.yellow("Total"),
				"",
				import_picocolors$4.default.yellow(formatNumber(totals.inputTokens)),
				import_picocolors$4.default.yellow(formatNumber(totals.outputTokens)),
				import_picocolors$4.default.yellow(formatNumber(totals.cacheCreationTokens)),
				import_picocolors$4.default.yellow(formatNumber(totals.cacheReadTokens)),
				import_picocolors$4.default.yellow(formatNumber(getTotalTokens(totals))),
				import_picocolors$4.default.yellow(formatCurrency(totals.totalCost))
			]), log(table.toString()), table.isCompactMode()) logger.info("\nRunning in Compact Mode"), logger.info("Expand terminal width to see cache metrics and total tokens");
		}
	}
});
var RequestError = class extends Error {
	constructor(message, options) {
		super(message, options), this.name = "RequestError";
	}
}, toRequestError = (e) => {
	return e instanceof RequestError ? e : new RequestError(e.message, { cause: e });
}, GlobalRequest = global.Request, Request = class extends GlobalRequest {
	constructor(input, options) {
		if (typeof input === "object" && getRequestCache in input) input = input[getRequestCache]();
		if (typeof options?.body?.getReader !== "undefined") options.duplex ??= "half";
		super(input, options);
	}
}, wrapBodyStream = Symbol("wrapBodyStream"), newRequestFromIncoming = (method, url, incoming, abortController) => {
	const headerRecord = [], rawHeaders = incoming.rawHeaders;
	for (let i = 0; i < rawHeaders.length; i += 2) {
		const { [i]: key, [i + 1]: value } = rawHeaders;
		if (key.charCodeAt(0) !== 58) headerRecord.push([key, value]);
	}
	const init$1 = {
		method,
		headers: headerRecord,
		signal: abortController.signal
	};
	if (method === "TRACE") {
		init$1.method = "GET";
		const req = new Request(url, init$1);
		return Object.defineProperty(req, "method", { get() {
			return "TRACE";
		} }), req;
	}
	if (!(method === "GET" || method === "HEAD")) if ("rawBody" in incoming && incoming.rawBody instanceof Buffer) init$1.body = new ReadableStream({ start(controller) {
		controller.enqueue(incoming.rawBody), controller.close();
	} });
	else if (incoming[wrapBodyStream]) {
		let reader;
		init$1.body = new ReadableStream({ async pull(controller) {
			try {
				reader ||= Readable.toWeb(incoming).getReader();
				const { done, value } = await reader.read();
				if (done) controller.close();
				else controller.enqueue(value);
			} catch (error) {
				controller.error(error);
			}
		} });
	} else init$1.body = Readable.toWeb(incoming);
	return new Request(url, init$1);
}, getRequestCache = Symbol("getRequestCache"), requestCache = Symbol("requestCache"), incomingKey = Symbol("incomingKey"), urlKey = Symbol("urlKey"), abortControllerKey = Symbol("abortControllerKey"), getAbortController = Symbol("getAbortController"), requestPrototype = {
	get method() {
		return this[incomingKey].method || "GET";
	},
	get url() {
		return this[urlKey];
	},
	[getAbortController]() {
		return this[getRequestCache](), this[abortControllerKey];
	},
	[getRequestCache]() {
		return this[abortControllerKey] ||= new AbortController(), this[requestCache] ||= newRequestFromIncoming(this.method, this[urlKey], this[incomingKey], this[abortControllerKey]);
	}
};
[
	"body",
	"bodyUsed",
	"cache",
	"credentials",
	"destination",
	"headers",
	"integrity",
	"mode",
	"redirect",
	"referrer",
	"referrerPolicy",
	"signal",
	"keepalive"
].forEach((k) => {
	Object.defineProperty(requestPrototype, k, { get() {
		return this[getRequestCache]()[k];
	} });
}), [
	"arrayBuffer",
	"blob",
	"clone",
	"formData",
	"json",
	"text"
].forEach((k) => {
	Object.defineProperty(requestPrototype, k, { value: function() {
		return this[getRequestCache]()[k]();
	} });
}), Object.setPrototypeOf(requestPrototype, Request.prototype);
var newRequest = (incoming, defaultHostname) => {
	const req = Object.create(requestPrototype);
	req[incomingKey] = incoming;
	const incomingUrl = incoming.url || "";
	if (incomingUrl[0] !== "/" && (incomingUrl.startsWith("http://") || incomingUrl.startsWith("https://"))) {
		if (incoming instanceof Http2ServerRequest) throw new RequestError("Absolute URL for :path is not allowed in HTTP/2");
		try {
			const url2 = new URL(incomingUrl);
			req[urlKey] = url2.href;
		} catch (e) {
			throw new RequestError("Invalid absolute URL", { cause: e });
		}
		return req;
	}
	const host = (incoming instanceof Http2ServerRequest ? incoming.authority : incoming.headers.host) || defaultHostname;
	if (!host) throw new RequestError("Missing host header");
	let scheme;
	if (incoming instanceof Http2ServerRequest) {
		if (scheme = incoming.scheme, !(scheme === "http" || scheme === "https")) throw new RequestError("Unsupported scheme");
	} else scheme = incoming.socket && incoming.socket.encrypted ? "https" : "http";
	const url = new URL(`${scheme}://${host}${incomingUrl}`);
	if (url.hostname.length !== host.length && url.hostname !== host.replace(/:\d+$/, "")) throw new RequestError("Invalid host header");
	return req[urlKey] = url.href, req;
}, responseCache = Symbol("responseCache"), getResponseCache = Symbol("getResponseCache"), cacheKey = Symbol("cache"), GlobalResponse = global.Response, Response2 = class _Response {
	#body;
	#init;
	[getResponseCache]() {
		return delete this[cacheKey], this[responseCache] ||= new GlobalResponse(this.#body, this.#init);
	}
	constructor(body, init$1) {
		let headers;
		if (this.#body = body, init$1 instanceof _Response) {
			const cachedGlobalResponse = init$1[responseCache];
			if (cachedGlobalResponse) {
				this.#init = cachedGlobalResponse, this[getResponseCache]();
				return;
			} else this.#init = init$1.#init, headers = new Headers(init$1.#init.headers);
		} else this.#init = init$1;
		if (typeof body === "string" || typeof body?.getReader !== "undefined" || body instanceof Blob || body instanceof Uint8Array) headers ||= init$1?.headers || { "content-type": "text/plain; charset=UTF-8" }, this[cacheKey] = [
			init$1?.status || 200,
			body,
			headers
		];
	}
	get headers() {
		const cache = this[cacheKey];
		if (cache) {
			if (!(cache[2] instanceof Headers)) cache[2] = new Headers(cache[2]);
			return cache[2];
		}
		return this[getResponseCache]().headers;
	}
	get status() {
		return this[cacheKey]?.[0] ?? this[getResponseCache]().status;
	}
	get ok() {
		const status = this.status;
		return status >= 200 && status < 300;
	}
};
[
	"body",
	"bodyUsed",
	"redirected",
	"statusText",
	"trailers",
	"type",
	"url"
].forEach((k) => {
	Object.defineProperty(Response2.prototype, k, { get() {
		return this[getResponseCache]()[k];
	} });
}), [
	"arrayBuffer",
	"blob",
	"clone",
	"formData",
	"json",
	"text"
].forEach((k) => {
	Object.defineProperty(Response2.prototype, k, { value: function() {
		return this[getResponseCache]()[k]();
	} });
}), Object.setPrototypeOf(Response2, GlobalResponse), Object.setPrototypeOf(Response2.prototype, GlobalResponse.prototype);
async function readWithoutBlocking(readPromise) {
	return Promise.race([readPromise, Promise.resolve().then(() => Promise.resolve(void 0))]);
}
function writeFromReadableStreamDefaultReader(reader, writable, currentReadPromise) {
	const handleError = () => {};
	return writable.on("error", handleError), (currentReadPromise ?? reader.read()).then(flow, handleStreamError), reader.closed.finally(() => {
		writable.off("error", handleError);
	});
	function handleStreamError(error) {
		if (error) writable.destroy(error);
	}
	function onDrain() {
		reader.read().then(flow, handleStreamError);
	}
	function flow({ done, value }) {
		try {
			if (done) writable.end();
			else if (!writable.write(value)) writable.once("drain", onDrain);
			else return reader.read().then(flow, handleStreamError);
		} catch (e) {
			handleStreamError(e);
		}
	}
}
function writeFromReadableStream(stream, writable) {
	if (stream.locked) throw new TypeError("ReadableStream is locked.");
	return writable.destroyed ? void 0 : writeFromReadableStreamDefaultReader(stream.getReader(), writable);
}
var buildOutgoingHttpHeaders = (headers) => {
	const res = {};
	if (!(headers instanceof Headers)) headers = new Headers(headers ?? void 0);
	const cookies = [];
	for (const [k, v] of headers) if (k === "set-cookie") cookies.push(v);
	else res[k] = v;
	if (cookies.length > 0) res["set-cookie"] = cookies;
	return res["content-type"] ??= "text/plain; charset=UTF-8", res;
}, X_ALREADY_SENT = "x-hono-already-sent", webFetch = global.fetch;
if (typeof global.crypto === "undefined") global.crypto = crypto;
global.fetch = (info$1, init$1) => {
	return init$1 = {
		compress: false,
		...init$1
	}, webFetch(info$1, init$1);
};
var outgoingEnded = Symbol("outgoingEnded"), handleRequestError = () => new Response(null, { status: 400 }), handleFetchError = (e) => new Response(null, { status: e instanceof Error && (e.name === "TimeoutError" || e.constructor.name === "TimeoutError") ? 504 : 500 }), handleResponseError = (e, outgoing) => {
	const err = e instanceof Error ? e : new Error("unknown error", { cause: e });
	if (err.code === "ERR_STREAM_PREMATURE_CLOSE") console.info("The user aborted a request.");
	else {
		if (console.error(e), !outgoing.headersSent) outgoing.writeHead(500, { "Content-Type": "text/plain" });
		outgoing.end(`Error: ${err.message}`), outgoing.destroy(err);
	}
}, flushHeaders = (outgoing) => {
	if ("flushHeaders" in outgoing && outgoing.writable) outgoing.flushHeaders();
}, responseViaCache = async (res, outgoing) => {
	let [status, body, header] = res[cacheKey];
	if (header instanceof Headers) header = buildOutgoingHttpHeaders(header);
	if (typeof body === "string") header["Content-Length"] = Buffer.byteLength(body);
	else if (body instanceof Uint8Array) header["Content-Length"] = body.byteLength;
	else if (body instanceof Blob) header["Content-Length"] = body.size;
	if (outgoing.writeHead(status, header), typeof body === "string" || body instanceof Uint8Array) outgoing.end(body);
	else if (body instanceof Blob) outgoing.end(new Uint8Array(await body.arrayBuffer()));
	else flushHeaders(outgoing), await writeFromReadableStream(body, outgoing)?.catch((e) => handleResponseError(e, outgoing));
	outgoing[outgoingEnded]?.();
}, responseViaResponseObject = async (res, outgoing, options = {}) => {
	if (res instanceof Promise) if (options.errorHandler) try {
		res = await res;
	} catch (err) {
		const errRes = await options.errorHandler(err);
		if (!errRes) return;
		res = errRes;
	}
	else res = await res.catch(handleFetchError);
	if (cacheKey in res) return responseViaCache(res, outgoing);
	const resHeaderRecord = buildOutgoingHttpHeaders(res.headers);
	if (res.body) {
		const reader = res.body.getReader(), values = [];
		let done = false, currentReadPromise = void 0, maxReadCount = 2;
		for (let i = 0; i < maxReadCount; i++) {
			currentReadPromise ||= reader.read();
			const chunk = await readWithoutBlocking(currentReadPromise).catch((e) => {
				console.error(e), done = true;
			});
			if (!chunk) {
				if (i === 1 && resHeaderRecord["transfer-encoding"] !== "chunked") {
					await new Promise((resolve) => setTimeout(resolve)), maxReadCount = 3;
					continue;
				}
				break;
			}
			if (currentReadPromise = void 0, chunk.value) values.push(chunk.value);
			if (chunk.done) {
				done = true;
				break;
			}
		}
		if (done && !("content-length" in resHeaderRecord)) resHeaderRecord["content-length"] = values.reduce((acc, value) => acc + value.length, 0);
		if (outgoing.writeHead(res.status, resHeaderRecord), values.forEach((value) => {
			outgoing.write(value);
		}), done) outgoing.end();
		else {
			if (values.length === 0) flushHeaders(outgoing);
			await writeFromReadableStreamDefaultReader(reader, outgoing, currentReadPromise);
		}
	} else if (resHeaderRecord[X_ALREADY_SENT]) {} else outgoing.writeHead(res.status, resHeaderRecord), outgoing.end();
	outgoing[outgoingEnded]?.();
}, getRequestListener = (fetchCallback, options = {}) => {
	const autoCleanupIncoming = options.autoCleanupIncoming ?? true;
	if (options.overrideGlobalObjects !== false && global.Request !== Request) Object.defineProperty(global, "Request", { value: Request }), Object.defineProperty(global, "Response", { value: Response2 });
	return async (incoming, outgoing) => {
		let res, req;
		try {
			req = newRequest(incoming, options.hostname);
			let incomingEnded = !autoCleanupIncoming || incoming.method === "GET" || incoming.method === "HEAD";
			if (!incomingEnded) {
				if (incoming[wrapBodyStream] = true, incoming.on("end", () => {
					incomingEnded = true;
				}), incoming instanceof Http2ServerRequest) outgoing[outgoingEnded] = () => {
					if (!incomingEnded) setTimeout(() => {
						if (!incomingEnded) setTimeout(() => {
							incoming.destroy(), outgoing.destroy();
						});
					});
				};
			}
			if (outgoing.on("close", () => {
				const abortController = req[abortControllerKey];
				if (abortController) {
					if (incoming.errored) req[abortControllerKey].abort(incoming.errored.toString());
					else if (!outgoing.writableFinished) req[abortControllerKey].abort("Client connection prematurely closed.");
				}
				if (!incomingEnded) setTimeout(() => {
					if (!incomingEnded) setTimeout(() => {
						incoming.destroy();
					});
				});
			}), res = fetchCallback(req, {
				incoming,
				outgoing
			}), cacheKey in res) return responseViaCache(res, outgoing);
		} catch (e) {
			if (!res) if (options.errorHandler) {
				if (res = await options.errorHandler(req ? e : toRequestError(e)), !res) return;
			} else if (!req) res = handleRequestError();
			else res = handleFetchError(e);
			else return handleResponseError(e, outgoing);
		}
		try {
			return await responseViaResponseObject(res, outgoing, options);
		} catch (e) {
			return handleResponseError(e, outgoing);
		}
	};
}, createAdaptorServer = (options) => {
	const fetchCallback = options.fetch, requestListener = getRequestListener(fetchCallback, {
		hostname: options.hostname,
		overrideGlobalObjects: options.overrideGlobalObjects,
		autoCleanupIncoming: options.autoCleanupIncoming
	}), createServer$1 = options.createServer || createServer, server = createServer$1(options.serverOptions || {}, requestListener);
	return server;
}, serve = (options, listeningListener) => {
	const server = createAdaptorServer(options);
	return server.listen(options?.port ?? 3e3, options.hostname, () => {
		const serverInfo = server.address();
		listeningListener && listeningListener(serverInfo);
	}), server;
};
const mcpCommand = define({
	name: "mcp",
	description: "Start MCP server with usage reporting tools",
	args: {
		mode: sharedArgs.mode,
		type: {
			type: "enum",
			short: "t",
			description: "Transport type for MCP server",
			choices: ["stdio", "http"],
			default: "stdio"
		},
		port: {
			type: "number",
			description: `Port for HTTP transport (default: ${MCP_DEFAULT_PORT})`,
			default: MCP_DEFAULT_PORT
		}
	},
	async run(ctx) {
		const { type, mode, port } = ctx.values;
		if (type === "stdio") logger.level = 0;
		const paths = getClaudePaths();
		if (paths.length === 0) throw logger.error("No valid Claude data directory found"), new Error("No valid Claude data directory found");
		const options = {
			claudePath: paths[0],
			mode
		};
		if (type === "stdio") {
			const server = createMcpServer(options);
			await startMcpServerStdio(server);
		} else {
			const app = createMcpHttpApp(options);
			serve({
				fetch: app.fetch,
				port
			}), logger.info(`MCP server is running on http://localhost:${port}`);
		}
	}
});
var import_picocolors$3 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
const monthlyCommand = define({
	name: "monthly",
	description: "Show usage report grouped by month",
	...sharedCommandConfig,
	async run(ctx) {
		const useJson = ctx.values.json || ctx.values.jq != null;
		if (useJson) logger.level = 0;
		const monthlyData = await loadMonthlyUsageData({
			since: ctx.values.since,
			until: ctx.values.until,
			mode: ctx.values.mode,
			order: ctx.values.order,
			offline: ctx.values.offline,
			timezone: ctx.values.timezone,
			locale: ctx.values.locale
		});
		if (monthlyData.length === 0) {
			if (useJson) {
				const emptyOutput = {
					monthly: [],
					totals: {
						inputTokens: 0,
						outputTokens: 0,
						cacheCreationTokens: 0,
						cacheReadTokens: 0,
						totalTokens: 0,
						totalCost: 0
					}
				};
				log(JSON.stringify(emptyOutput, null, 2));
			} else logger.warn("No Claude usage data found.");
			process$1.exit(0);
		}
		const totals = calculateTotals(monthlyData);
		if (ctx.values.debug && !useJson) {
			const mismatchStats = await detectMismatches(void 0);
			printMismatchReport(mismatchStats, ctx.values.debugSamples);
		}
		if (useJson) {
			const jsonOutput = {
				monthly: monthlyData.map((data) => ({
					month: data.month,
					inputTokens: data.inputTokens,
					outputTokens: data.outputTokens,
					cacheCreationTokens: data.cacheCreationTokens,
					cacheReadTokens: data.cacheReadTokens,
					totalTokens: getTotalTokens(data),
					totalCost: data.totalCost,
					modelsUsed: data.modelsUsed,
					modelBreakdowns: data.modelBreakdowns
				})),
				totals: createTotalsObject(totals)
			};
			if (ctx.values.jq != null) {
				const jqResult = await processWithJq(jsonOutput, ctx.values.jq);
				if (isFailure(jqResult)) logger.error(jqResult.error.message), process$1.exit(1);
				log(jqResult.value);
			} else log(JSON.stringify(jsonOutput, null, 2));
		} else {
			logger.box("Claude Code Token Usage Report - Monthly");
			const table = new ResponsiveTable({
				head: [
					"Month",
					"Models",
					"Input",
					"Output",
					"Cache Create",
					"Cache Read",
					"Total Tokens",
					"Cost (USD)"
				],
				style: { head: ["cyan"] },
				colAligns: [
					"left",
					"left",
					"right",
					"right",
					"right",
					"right",
					"right",
					"right"
				],
				dateFormatter: (dateStr) => formatDateCompact(dateStr, ctx.values.timezone, ctx.values.locale),
				compactHead: [
					"Month",
					"Models",
					"Input",
					"Output",
					"Cost (USD)"
				],
				compactColAligns: [
					"left",
					"left",
					"right",
					"right",
					"right"
				],
				compactThreshold: 100
			});
			for (const data of monthlyData) if (table.push([
				data.month,
				formatModelsDisplayMultiline(data.modelsUsed),
				formatNumber(data.inputTokens),
				formatNumber(data.outputTokens),
				formatNumber(data.cacheCreationTokens),
				formatNumber(data.cacheReadTokens),
				formatNumber(getTotalTokens(data)),
				formatCurrency(data.totalCost)
			]), ctx.values.breakdown) pushBreakdownRows(table, data.modelBreakdowns);
			if (table.push([
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			]), table.push([
				import_picocolors$3.default.yellow("Total"),
				"",
				import_picocolors$3.default.yellow(formatNumber(totals.inputTokens)),
				import_picocolors$3.default.yellow(formatNumber(totals.outputTokens)),
				import_picocolors$3.default.yellow(formatNumber(totals.cacheCreationTokens)),
				import_picocolors$3.default.yellow(formatNumber(totals.cacheReadTokens)),
				import_picocolors$3.default.yellow(formatNumber(getTotalTokens(totals))),
				import_picocolors$3.default.yellow(formatCurrency(totals.totalCost))
			]), log(table.toString()), table.isCompactMode()) logger.info("\nRunning in Compact Mode"), logger.info("Expand terminal width to see cache metrics and total tokens");
		}
	}
});
async function handleSessionIdLookup(ctx, useJson) {
	const sessionUsage = await loadSessionUsageById(ctx.values.id, {
		mode: ctx.values.mode,
		offline: ctx.values.offline
	});
	if (sessionUsage == null) {
		if (useJson) log(JSON.stringify(null));
		else logger.warn(`No session found with ID: ${ctx.values.id}`);
		process$1.exit(0);
	}
	if (useJson) {
		const jsonOutput = {
			sessionId: ctx.values.id,
			totalCost: sessionUsage.totalCost,
			totalTokens: calculateSessionTotalTokens(sessionUsage.entries),
			entries: sessionUsage.entries.map((entry) => ({
				timestamp: entry.timestamp,
				inputTokens: entry.message.usage.input_tokens,
				outputTokens: entry.message.usage.output_tokens,
				cacheCreationTokens: entry.message.usage.cache_creation_input_tokens ?? 0,
				cacheReadTokens: entry.message.usage.cache_read_input_tokens ?? 0,
				model: entry.message.model ?? "unknown",
				costUSD: entry.costUSD ?? 0
			}))
		};
		if (ctx.values.jq != null) {
			const jqResult = await processWithJq(jsonOutput, ctx.values.jq);
			if (isFailure(jqResult)) logger.error(jqResult.error.message), process$1.exit(1);
			log(jqResult.value);
		} else log(JSON.stringify(jsonOutput, null, 2));
	} else {
		logger.box(`Claude Code Session Usage - ${ctx.values.id}`);
		const totalTokens = calculateSessionTotalTokens(sessionUsage.entries);
		if (log(`Total Cost: ${formatCurrency(sessionUsage.totalCost)}`), log(`Total Tokens: ${formatNumber(totalTokens)}`), log(`Total Entries: ${sessionUsage.entries.length}`), log(""), sessionUsage.entries.length > 0) {
			const table = new ResponsiveTable({
				head: [
					"Timestamp",
					"Model",
					"Input",
					"Output",
					"Cache Create",
					"Cache Read",
					"Cost (USD)"
				],
				style: { head: ["cyan"] },
				colAligns: [
					"left",
					"left",
					"right",
					"right",
					"right",
					"right",
					"right"
				]
			});
			for (const entry of sessionUsage.entries) table.push([
				formatDateCompact(entry.timestamp, ctx.values.timezone, ctx.values.locale),
				entry.message.model ?? "unknown",
				formatNumber(entry.message.usage.input_tokens),
				formatNumber(entry.message.usage.output_tokens),
				formatNumber(entry.message.usage.cache_creation_input_tokens ?? 0),
				formatNumber(entry.message.usage.cache_read_input_tokens ?? 0),
				formatCurrency(entry.costUSD ?? 0)
			]);
			log(table.toString());
		}
	}
}
function calculateSessionTotalTokens(entries) {
	return entries.reduce((sum, entry) => {
		const usage = entry.message.usage;
		return sum + usage.input_tokens + usage.output_tokens + (usage.cache_creation_input_tokens ?? 0) + (usage.cache_read_input_tokens ?? 0);
	}, 0);
}
var import_picocolors$2 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
const sessionCommand = define({
	name: "session",
	description: "Show usage report grouped by conversation session",
	...sharedCommandConfig,
	args: {
		...sharedCommandConfig.args,
		id: {
			type: "string",
			short: "i",
			description: "Load usage data for a specific session ID"
		}
	},
	toKebab: true,
	async run(ctx) {
		const useJson = ctx.values.json || ctx.values.jq != null;
		if (useJson) logger.level = 0;
		if (ctx.values.id != null) return handleSessionIdLookup({ values: {
			id: ctx.values.id,
			mode: ctx.values.mode,
			offline: ctx.values.offline,
			jq: ctx.values.jq,
			timezone: ctx.values.timezone,
			locale: ctx.values.locale ?? "en-CA"
		} }, useJson);
		const sessionData = await loadSessionData({
			since: ctx.values.since,
			until: ctx.values.until,
			mode: ctx.values.mode,
			order: ctx.values.order,
			offline: ctx.values.offline,
			timezone: ctx.values.timezone,
			locale: ctx.values.locale
		});
		if (sessionData.length === 0) {
			if (useJson) log(JSON.stringify([]));
			else logger.warn("No Claude usage data found.");
			process$1.exit(0);
		}
		const totals = calculateTotals(sessionData);
		if (ctx.values.debug && !useJson) {
			const mismatchStats = await detectMismatches(void 0);
			printMismatchReport(mismatchStats, ctx.values.debugSamples);
		}
		if (useJson) {
			const jsonOutput = {
				sessions: sessionData.map((data) => ({
					sessionId: data.sessionId,
					inputTokens: data.inputTokens,
					outputTokens: data.outputTokens,
					cacheCreationTokens: data.cacheCreationTokens,
					cacheReadTokens: data.cacheReadTokens,
					totalTokens: getTotalTokens(data),
					totalCost: data.totalCost,
					lastActivity: data.lastActivity,
					modelsUsed: data.modelsUsed,
					modelBreakdowns: data.modelBreakdowns,
					projectPath: data.projectPath
				})),
				totals: createTotalsObject(totals)
			};
			if (ctx.values.jq != null) {
				const jqResult = await processWithJq(jsonOutput, ctx.values.jq);
				if (isFailure(jqResult)) logger.error(jqResult.error.message), process$1.exit(1);
				log(jqResult.value);
			} else log(JSON.stringify(jsonOutput, null, 2));
		} else {
			logger.box("Claude Code Token Usage Report - By Session");
			const table = new ResponsiveTable({
				head: [
					"Session",
					"Models",
					"Input",
					"Output",
					"Cache Create",
					"Cache Read",
					"Total Tokens",
					"Cost (USD)",
					"Last Activity"
				],
				style: { head: ["cyan"] },
				colAligns: [
					"left",
					"left",
					"right",
					"right",
					"right",
					"right",
					"right",
					"right",
					"left"
				],
				dateFormatter: (dateStr) => formatDateCompact(dateStr, ctx.values.timezone, ctx.values.locale),
				compactHead: [
					"Session",
					"Models",
					"Input",
					"Output",
					"Cost (USD)",
					"Last Activity"
				],
				compactColAligns: [
					"left",
					"left",
					"right",
					"right",
					"right",
					"left"
				],
				compactThreshold: 100
			});
			let maxSessionLength = 0;
			for (const data of sessionData) {
				const sessionDisplay = data.sessionId.split("-").slice(-2).join("-");
				if (maxSessionLength = Math.max(maxSessionLength, sessionDisplay.length), table.push([
					sessionDisplay,
					formatModelsDisplayMultiline(data.modelsUsed),
					formatNumber(data.inputTokens),
					formatNumber(data.outputTokens),
					formatNumber(data.cacheCreationTokens),
					formatNumber(data.cacheReadTokens),
					formatNumber(getTotalTokens(data)),
					formatCurrency(data.totalCost),
					data.lastActivity
				]), ctx.values.breakdown) pushBreakdownRows(table, data.modelBreakdowns, 1, 1);
			}
			if (table.push([
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			]), table.push([
				import_picocolors$2.default.yellow("Total"),
				"",
				import_picocolors$2.default.yellow(formatNumber(totals.inputTokens)),
				import_picocolors$2.default.yellow(formatNumber(totals.outputTokens)),
				import_picocolors$2.default.yellow(formatNumber(totals.cacheCreationTokens)),
				import_picocolors$2.default.yellow(formatNumber(totals.cacheReadTokens)),
				import_picocolors$2.default.yellow(formatNumber(getTotalTokens(totals))),
				import_picocolors$2.default.yellow(formatCurrency(totals.totalCost)),
				""
			]), log(table.toString()), table.isCompactMode()) logger.info("\nRunning in Compact Mode"), logger.info("Expand terminal width to see cache metrics and total tokens");
		}
	}
}), { stdin: stdin$1 } = process;
async function getStdin() {
	let result = "";
	if (stdin$1.isTTY) return result;
	stdin$1.setEncoding("utf8");
	for await (const chunk of stdin$1) result += chunk;
	return result;
}
getStdin.buffer = async () => {
	const result = [];
	let length = 0;
	if (stdin$1.isTTY) return Buffer.concat([]);
	for await (const chunk of stdin$1) result.push(chunk), length += chunk.length;
	return Buffer.concat(result, length);
};
var import_picocolors$1 = /* @__PURE__ */ __toESM(require_picocolors(), 1);
function formatRemainingTime(remaining) {
	const remainingHours = Math.floor(remaining / 60), remainingMins = remaining % 60;
	return remainingHours > 0 ? `${remainingHours}h ${remainingMins}m left` : `${remainingMins}m left`;
}
const statuslineCommand = define({
	name: "statusline",
	description: "Display compact status line for Claude Code hooks (Beta)",
	args: { offline: {
		...sharedArgs.offline,
		default: true
	} },
	async run(ctx) {
		logger.level = 0;
		const stdin$2 = await getStdin();
		if (stdin$2.length === 0) log(" No input provided"), process$1.exit(1);
		const hookDataJson = JSON.parse(stdin$2.trim()), hookDataParseResult = statuslineHookJsonSchema.safeParse(hookDataJson);
		if (!hookDataParseResult.success) log(" Invalid input format:", hookDataParseResult.error.message), process$1.exit(1);
		const hookData = hookDataParseResult.data, claudePaths = getClaudePaths();
		if (claudePaths.length === 0) log(" No Claude data directory found"), process$1.exit(1);
		const sessionId = hookData.session_id;
		let sessionCost = null;
		try {
			const sessionData = await loadSessionUsageById(sessionId, {
				mode: "auto",
				offline: ctx.values.offline
			});
			if (sessionData != null) sessionCost = sessionData.totalCost;
		} catch (error) {
			logger.error("Failed to load session data:", error);
		}
		const today = /* @__PURE__ */ new Date(), todayStr = today.toISOString().split("T")[0]?.replace(/-/g, "") ?? "";
		let todayCost = 0;
		try {
			const dailyData = await loadDailyUsageData({
				since: todayStr,
				until: todayStr,
				mode: "auto",
				offline: ctx.values.offline
			});
			if (dailyData.length > 0) {
				const totals = calculateTotals(dailyData);
				todayCost = totals.totalCost;
			}
		} catch (error) {
			logger.error("Failed to load daily data:", error);
		}
		let blockInfo = "", burnRateInfo = "";
		try {
			const blocks = await loadSessionBlockData({
				mode: "auto",
				offline: ctx.values.offline
			});
			if (blocks.length === 0) blockInfo = "No active block";
			else {
				const activeBlock = blocks.find((block) => {
					return !!block.isActive;
				});
				if (activeBlock != null) {
					const now = /* @__PURE__ */ new Date(), remaining = Math.round((activeBlock.endTime.getTime() - now.getTime()) / (1e3 * 60)), blockCost = activeBlock.costUSD;
					blockInfo = `${formatCurrency(blockCost)} block (${formatRemainingTime(remaining)})`;
					const burnRate = calculateBurnRate(activeBlock);
					if (burnRate != null) {
						const costPerHour = burnRate.costPerHour, costPerHourStr = `${formatCurrency(costPerHour)}/hr`;
						let coloredBurnRate = costPerHourStr;
						if (burnRate.tokensPerMinuteForIndicator < 2e3) coloredBurnRate = import_picocolors$1.default.green(costPerHourStr);
						else if (burnRate.tokensPerMinuteForIndicator < 5e3) coloredBurnRate = import_picocolors$1.default.yellow(costPerHourStr);
						else coloredBurnRate = import_picocolors$1.default.red(costPerHourStr);
						burnRateInfo = ` |  ${coloredBurnRate}`;
					}
				} else blockInfo = "No active block";
			}
		} catch (error) {
			logger.error("Failed to load block data:", error), blockInfo = "No active block";
		}
		let contextInfo = "";
		try {
			const contextData = await calculateContextTokens(hookData.transcript_path);
			if (contextData != null) {
				const p$1 = contextData.percentage, thresholds = getContextUsageThresholds(), color = p$1 < thresholds.LOW ? import_picocolors$1.default.green : p$1 < thresholds.MEDIUM ? import_picocolors$1.default.yellow : import_picocolors$1.default.red, coloredPercentage = color(`${p$1}%`), tokenDisplay = contextData.inputTokens.toLocaleString();
				contextInfo = ` |  ${tokenDisplay} (${coloredPercentage})`;
			}
		} catch (error) {
			logger.debug(`Failed to calculate context tokens: ${error instanceof Error ? error.message : String(error)}`);
		}
		const modelName = hookData.model.display_name, sessionDisplay = sessionCost !== null ? formatCurrency(sessionCost) : "N/A", statusLine = ` ${modelName} |  ${sessionDisplay} session / ${formatCurrency(todayCost)} today / ${blockInfo}${burnRateInfo}${contextInfo}`;
		log(statusLine);
	}
});
var import_picocolors = /* @__PURE__ */ __toESM(require_picocolors(), 1);
const weeklyCommand = define({
	name: "weekly",
	description: "Show usage report grouped by week",
	args: {
		...sharedArgs,
		startOfWeek: {
			type: "enum",
			short: "w",
			description: "Day to start the week on",
			default: "sunday",
			choices: WEEK_DAYS
		}
	},
	toKebab: true,
	async run(ctx) {
		const useJson = ctx.values.json || ctx.values.jq != null;
		if (useJson) logger.level = 0;
		const weeklyData = await loadWeeklyUsageData({
			since: ctx.values.since,
			until: ctx.values.until,
			timezone: ctx.values.timezone,
			mode: ctx.values.mode,
			order: ctx.values.order,
			offline: ctx.values.offline,
			startOfWeek: ctx.values.startOfWeek,
			locale: ctx.values.locale
		});
		if (weeklyData.length === 0) {
			if (useJson) {
				const emptyOutput = {
					weekly: [],
					totals: {
						inputTokens: 0,
						outputTokens: 0,
						cacheCreationTokens: 0,
						cacheReadTokens: 0,
						totalTokens: 0,
						totalCost: 0
					}
				};
				log(JSON.stringify(emptyOutput, null, 2));
			} else logger.warn("No Claude usage data found.");
			process$1.exit(0);
		}
		const totals = calculateTotals(weeklyData);
		if (ctx.values.debug && !useJson) {
			const mismatchStats = await detectMismatches(void 0);
			printMismatchReport(mismatchStats, ctx.values.debugSamples);
		}
		if (useJson) {
			const jsonOutput = {
				weekly: weeklyData.map((data) => ({
					week: data.week,
					inputTokens: data.inputTokens,
					outputTokens: data.outputTokens,
					cacheCreationTokens: data.cacheCreationTokens,
					cacheReadTokens: data.cacheReadTokens,
					totalTokens: getTotalTokens(data),
					totalCost: data.totalCost,
					modelsUsed: data.modelsUsed,
					modelBreakdowns: data.modelBreakdowns
				})),
				totals: createTotalsObject(totals)
			};
			if (ctx.values.jq != null) {
				const jqResult = await processWithJq(jsonOutput, ctx.values.jq);
				if (isFailure(jqResult)) logger.error(jqResult.error.message), process$1.exit(1);
				log(jqResult.value);
			} else log(JSON.stringify(jsonOutput, null, 2));
		} else {
			logger.box("Claude Code Token Usage Report - Weekly");
			const table = new ResponsiveTable({
				head: [
					"Week",
					"Models",
					"Input",
					"Output",
					"Cache Create",
					"Cache Read",
					"Total Tokens",
					"Cost (USD)"
				],
				style: { head: ["cyan"] },
				colAligns: [
					"left",
					"left",
					"right",
					"right",
					"right",
					"right",
					"right",
					"right"
				],
				dateFormatter: (dateStr) => formatDateCompact(dateStr, ctx.values.timezone, ctx.values.locale),
				compactHead: [
					"Week",
					"Models",
					"Input",
					"Output",
					"Cost (USD)"
				],
				compactColAligns: [
					"left",
					"left",
					"right",
					"right",
					"right"
				],
				compactThreshold: 100
			});
			for (const data of weeklyData) if (table.push([
				data.week,
				formatModelsDisplayMultiline(data.modelsUsed),
				formatNumber(data.inputTokens),
				formatNumber(data.outputTokens),
				formatNumber(data.cacheCreationTokens),
				formatNumber(data.cacheReadTokens),
				formatNumber(getTotalTokens(data)),
				formatCurrency(data.totalCost)
			]), ctx.values.breakdown) pushBreakdownRows(table, data.modelBreakdowns);
			if (table.push([
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			]), table.push([
				import_picocolors.default.yellow("Total"),
				"",
				import_picocolors.default.yellow(formatNumber(totals.inputTokens)),
				import_picocolors.default.yellow(formatNumber(totals.outputTokens)),
				import_picocolors.default.yellow(formatNumber(totals.cacheCreationTokens)),
				import_picocolors.default.yellow(formatNumber(totals.cacheReadTokens)),
				import_picocolors.default.yellow(formatNumber(getTotalTokens(totals))),
				import_picocolors.default.yellow(formatCurrency(totals.totalCost))
			]), log(table.toString()), table.isCompactMode()) logger.info("\nRunning in Compact Mode"), logger.info("Expand terminal width to see cache metrics and total tokens");
		}
	}
}), subCommands = /* @__PURE__ */ new Map();
subCommands.set("daily", dailyCommand), subCommands.set("monthly", monthlyCommand), subCommands.set("weekly", weeklyCommand), subCommands.set("session", sessionCommand), subCommands.set("blocks", blocksCommand), subCommands.set("mcp", mcpCommand), subCommands.set("statusline", statuslineCommand);
const mainCommand = dailyCommand;
await cli(process$1.argv.slice(2), mainCommand, {
	name,
	version,
	description,
	subCommands,
	renderHeader: null
});
export {};
