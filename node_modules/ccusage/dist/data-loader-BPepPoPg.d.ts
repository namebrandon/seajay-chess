import { Bucket, CostMode, PricingFetcher, SortOrder, TupleToUnion } from "./pricing-fetcher-B5m_kEpz.js";
import { z } from "zod";

//#region src/_consts.d.ts

/**
 * Days of the week for weekly aggregation
 */
declare const WEEK_DAYS: readonly ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
//#endregion
//#region src/_session-blocks.d.ts
/**
 * Represents a single usage data entry loaded from JSONL files
 */
type LoadedUsageEntry = {
  timestamp: Date;
  usage: {
    inputTokens: number;
    outputTokens: number;
    cacheCreationInputTokens: number;
    cacheReadInputTokens: number;
  };
  costUSD: number | null;
  model: string;
  version?: string;
  usageLimitResetTime?: Date; // Claude API usage limit reset time
};
/**
 * Aggregated token counts for different token types
 */
type TokenCounts = {
  inputTokens: number;
  outputTokens: number;
  cacheCreationInputTokens: number;
  cacheReadInputTokens: number;
};
/**
 * Represents a session block (typically 5-hour billing period) with usage data
 */
type SessionBlock = {
  id: string; // ISO string of block start time
  startTime: Date;
  endTime: Date; // startTime + 5 hours (for normal blocks) or gap end time (for gap blocks)
  actualEndTime?: Date; // Last activity in block
  isActive: boolean;
  isGap?: boolean; // True if this is a gap block
  entries: LoadedUsageEntry[];
  tokenCounts: TokenCounts;
  costUSD: number;
  models: string[];
  usageLimitResetTime?: Date; // Claude API usage limit reset time
};
/**
 * Represents usage burn rate calculations
 */
//#endregion
//#region src/data-loader.d.ts
/**
 * Get Claude data directories to search for usage data
 * When CLAUDE_CONFIG_DIR is set: uses only those paths
 * When not set: uses default paths (~/.config/claude and ~/.claude)
 * @returns Array of valid Claude data directory paths
 */
declare function getClaudePaths(): string[];
/**
 * Get context usage percentage thresholds for color coding
 * Can be configured via environment variables or uses defaults
 * Validates and clamps values to 0-100 range and enforces LOW < MEDIUM ordering
 * @returns Context usage thresholds with LOW and MEDIUM percentages
 */
declare function getContextUsageThresholds(): {
  readonly LOW: number;
  readonly MEDIUM: number;
};
/**
 * Extract project name from Claude JSONL file path
 * @param jsonlPath - Absolute path to JSONL file
 * @returns Project name extracted from path, or "unknown" if malformed
 */
declare function extractProjectFromPath(jsonlPath: string): string;
/**
 * Zod schema for validating Claude usage data from JSONL files
 */
declare const usageDataSchema: z.ZodObject<{
  cwd: z.ZodOptional<z.ZodString>;
  sessionId: z.ZodOptional<z.ZodBranded<z.ZodString, "SessionId">>;
  timestamp: z.ZodBranded<z.ZodString, "ISOTimestamp">;
  version: z.ZodOptional<z.ZodBranded<z.ZodString, "Version">>;
  message: z.ZodObject<{
    usage: z.ZodObject<{
      input_tokens: z.ZodNumber;
      output_tokens: z.ZodNumber;
      cache_creation_input_tokens: z.ZodOptional<z.ZodNumber>;
      cache_read_input_tokens: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
      input_tokens: number;
      output_tokens: number;
      cache_creation_input_tokens?: number | undefined;
      cache_read_input_tokens?: number | undefined;
    }, {
      input_tokens: number;
      output_tokens: number;
      cache_creation_input_tokens?: number | undefined;
      cache_read_input_tokens?: number | undefined;
    }>;
    model: z.ZodOptional<z.ZodBranded<z.ZodString, "ModelName">>;
    id: z.ZodOptional<z.ZodBranded<z.ZodString, "MessageId">>;
    content: z.ZodOptional<z.ZodArray<z.ZodObject<{
      text: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
      text?: string | undefined;
    }, {
      text?: string | undefined;
    }>, "many">>;
  }, "strip", z.ZodTypeAny, {
    usage: {
      input_tokens: number;
      output_tokens: number;
      cache_creation_input_tokens?: number | undefined;
      cache_read_input_tokens?: number | undefined;
    };
    model?: (string & z.BRAND<"ModelName">) | undefined;
    id?: (string & z.BRAND<"MessageId">) | undefined;
    content?: {
      text?: string | undefined;
    }[] | undefined;
  }, {
    usage: {
      input_tokens: number;
      output_tokens: number;
      cache_creation_input_tokens?: number | undefined;
      cache_read_input_tokens?: number | undefined;
    };
    model?: string | undefined;
    id?: string | undefined;
    content?: {
      text?: string | undefined;
    }[] | undefined;
  }>;
  costUSD: z.ZodOptional<z.ZodNumber>;
  requestId: z.ZodOptional<z.ZodBranded<z.ZodString, "RequestId">>;
  isApiErrorMessage: z.ZodOptional<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
  cwd?: string | undefined;
  sessionId?: (string & z.BRAND<"SessionId">) | undefined;
  timestamp: string & z.BRAND<"ISOTimestamp">;
  version?: (string & z.BRAND<"Version">) | undefined;
  message: {
    usage: {
      input_tokens: number;
      output_tokens: number;
      cache_creation_input_tokens?: number | undefined;
      cache_read_input_tokens?: number | undefined;
    };
    model?: (string & z.BRAND<"ModelName">) | undefined;
    id?: (string & z.BRAND<"MessageId">) | undefined;
    content?: {
      text?: string | undefined;
    }[] | undefined;
  };
  costUSD?: number | undefined;
  requestId?: (string & z.BRAND<"RequestId">) | undefined;
  isApiErrorMessage?: boolean | undefined;
}, {
  cwd?: string | undefined;
  sessionId?: string | undefined;
  timestamp: string;
  version?: string | undefined;
  message: {
    usage: {
      input_tokens: number;
      output_tokens: number;
      cache_creation_input_tokens?: number | undefined;
      cache_read_input_tokens?: number | undefined;
    };
    model?: string | undefined;
    id?: string | undefined;
    content?: {
      text?: string | undefined;
    }[] | undefined;
  };
  costUSD?: number | undefined;
  requestId?: string | undefined;
  isApiErrorMessage?: boolean | undefined;
}>;
/**
 * Zod schema for transcript usage data from Claude messages
 */
declare const transcriptUsageSchema: z.ZodObject<{
  input_tokens: z.ZodOptional<z.ZodNumber>;
  cache_creation_input_tokens: z.ZodOptional<z.ZodNumber>;
  cache_read_input_tokens: z.ZodOptional<z.ZodNumber>;
  output_tokens: z.ZodOptional<z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
  input_tokens?: number | undefined;
  cache_creation_input_tokens?: number | undefined;
  cache_read_input_tokens?: number | undefined;
  output_tokens?: number | undefined;
}, {
  input_tokens?: number | undefined;
  cache_creation_input_tokens?: number | undefined;
  cache_read_input_tokens?: number | undefined;
  output_tokens?: number | undefined;
}>;
/**
 * Zod schema for transcript message data
 */
declare const transcriptMessageSchema: z.ZodObject<{
  type: z.ZodOptional<z.ZodString>;
  message: z.ZodOptional<z.ZodObject<{
    usage: z.ZodOptional<z.ZodObject<{
      input_tokens: z.ZodOptional<z.ZodNumber>;
      cache_creation_input_tokens: z.ZodOptional<z.ZodNumber>;
      cache_read_input_tokens: z.ZodOptional<z.ZodNumber>;
      output_tokens: z.ZodOptional<z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
      input_tokens?: number | undefined;
      cache_creation_input_tokens?: number | undefined;
      cache_read_input_tokens?: number | undefined;
      output_tokens?: number | undefined;
    }, {
      input_tokens?: number | undefined;
      cache_creation_input_tokens?: number | undefined;
      cache_read_input_tokens?: number | undefined;
      output_tokens?: number | undefined;
    }>>;
  }, "strip", z.ZodTypeAny, {
    usage?: {
      input_tokens?: number | undefined;
      cache_creation_input_tokens?: number | undefined;
      cache_read_input_tokens?: number | undefined;
      output_tokens?: number | undefined;
    } | undefined;
  }, {
    usage?: {
      input_tokens?: number | undefined;
      cache_creation_input_tokens?: number | undefined;
      cache_read_input_tokens?: number | undefined;
      output_tokens?: number | undefined;
    } | undefined;
  }>>;
}, "strip", z.ZodTypeAny, {
  type?: string | undefined;
  message?: {
    usage?: {
      input_tokens?: number | undefined;
      cache_creation_input_tokens?: number | undefined;
      cache_read_input_tokens?: number | undefined;
      output_tokens?: number | undefined;
    } | undefined;
  } | undefined;
}, {
  type?: string | undefined;
  message?: {
    usage?: {
      input_tokens?: number | undefined;
      cache_creation_input_tokens?: number | undefined;
      cache_read_input_tokens?: number | undefined;
      output_tokens?: number | undefined;
    } | undefined;
  } | undefined;
}>;
/**
 * Type definition for Claude usage data entries from JSONL files
 */
type UsageData = z.infer<typeof usageDataSchema>;
/**
 * Zod schema for model-specific usage breakdown data
 */
declare const modelBreakdownSchema: z.ZodObject<{
  modelName: z.ZodBranded<z.ZodString, "ModelName">;
  inputTokens: z.ZodNumber;
  outputTokens: z.ZodNumber;
  cacheCreationTokens: z.ZodNumber;
  cacheReadTokens: z.ZodNumber;
  cost: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
  modelName: string & z.BRAND<"ModelName">;
  inputTokens: number;
  outputTokens: number;
  cacheCreationTokens: number;
  cacheReadTokens: number;
  cost: number;
}, {
  modelName: string;
  inputTokens: number;
  outputTokens: number;
  cacheCreationTokens: number;
  cacheReadTokens: number;
  cost: number;
}>;
/**
 * Type definition for model-specific usage breakdown
 */
type ModelBreakdown = z.infer<typeof modelBreakdownSchema>;
/**
 * Zod schema for daily usage aggregation data
 */
declare const dailyUsageSchema: z.ZodObject<{
  date: z.ZodBranded<z.ZodString, "DailyDate">;
  inputTokens: z.ZodNumber;
  outputTokens: z.ZodNumber;
  cacheCreationTokens: z.ZodNumber;
  cacheReadTokens: z.ZodNumber;
  totalCost: z.ZodNumber;
  modelsUsed: z.ZodArray<z.ZodBranded<z.ZodString, "ModelName">, "many">;
  modelBreakdowns: z.ZodArray<z.ZodObject<{
    modelName: z.ZodBranded<z.ZodString, "ModelName">;
    inputTokens: z.ZodNumber;
    outputTokens: z.ZodNumber;
    cacheCreationTokens: z.ZodNumber;
    cacheReadTokens: z.ZodNumber;
    cost: z.ZodNumber;
  }, "strip", z.ZodTypeAny, {
    modelName: string & z.BRAND<"ModelName">;
    inputTokens: number;
    outputTokens: number;
    cacheCreationTokens: number;
    cacheReadTokens: number;
    cost: number;
  }, {
    modelName: string;
    inputTokens: number;
    outputTokens: number;
    cacheCreationTokens: number;
    cacheReadTokens: number;
    cost: number;
  }>, "many">;
  project: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
  date: string & z.BRAND<"DailyDate">;
  inputTokens: number;
  outputTokens: number;
  cacheCreationTokens: number;
  cacheReadTokens: number;
  totalCost: number;
  modelsUsed: (string & z.BRAND<"ModelName">)[];
  modelBreakdowns: {
    modelName: string & z.BRAND<"ModelName">;
    inputTokens: number;
    outputTokens: number;
    cacheCreationTokens: number;
    cacheReadTokens: number;
    cost: number;
  }[];
  project?: string | undefined;
}, {
  date: string;
  inputTokens: number;
  outputTokens: number;
  cacheCreationTokens: number;
  cacheReadTokens: number;
  totalCost: number;
  modelsUsed: string[];
  modelBreakdowns: {
    modelName: string;
    inputTokens: number;
    outputTokens: number;
    cacheCreationTokens: number;
    cacheReadTokens: number;
    cost: number;
  }[];
  project?: string | undefined;
}>;
/**
 * Type definition for daily usage aggregation
 */
type DailyUsage = z.infer<typeof dailyUsageSchema>;
/**
 * Zod schema for session-based usage aggregation data
 */
declare const sessionUsageSchema: z.ZodObject<{
  sessionId: z.ZodBranded<z.ZodString, "SessionId">;
  projectPath: z.ZodBranded<z.ZodString, "ProjectPath">;
  inputTokens: z.ZodNumber;
  outputTokens: z.ZodNumber;
  cacheCreationTokens: z.ZodNumber;
  cacheReadTokens: z.ZodNumber;
  totalCost: z.ZodNumber;
  lastActivity: z.ZodBranded<z.ZodString, "ActivityDate">;
  versions: z.ZodArray<z.ZodBranded<z.ZodString, "Version">, "many">;
  modelsUsed: z.ZodArray<z.ZodBranded<z.ZodString, "ModelName">, "many">;
  modelBreakdowns: z.ZodArray<z.ZodObject<{
    modelName: z.ZodBranded<z.ZodString, "ModelName">;
    inputTokens: z.ZodNumber;
    outputTokens: z.ZodNumber;
    cacheCreationTokens: z.ZodNumber;
    cacheReadTokens: z.ZodNumber;
    cost: z.ZodNumber;
  }, "strip", z.ZodTypeAny, {
    modelName: string & z.BRAND<"ModelName">;
    inputTokens: number;
    outputTokens: number;
    cacheCreationTokens: number;
    cacheReadTokens: number;
    cost: number;
  }, {
    modelName: string;
    inputTokens: number;
    outputTokens: number;
    cacheCreationTokens: number;
    cacheReadTokens: number;
    cost: number;
  }>, "many">;
}, "strip", z.ZodTypeAny, {
  sessionId: string & z.BRAND<"SessionId">;
  projectPath: string & z.BRAND<"ProjectPath">;
  inputTokens: number;
  outputTokens: number;
  cacheCreationTokens: number;
  cacheReadTokens: number;
  totalCost: number;
  lastActivity: string & z.BRAND<"ActivityDate">;
  versions: (string & z.BRAND<"Version">)[];
  modelsUsed: (string & z.BRAND<"ModelName">)[];
  modelBreakdowns: {
    modelName: string & z.BRAND<"ModelName">;
    inputTokens: number;
    outputTokens: number;
    cacheCreationTokens: number;
    cacheReadTokens: number;
    cost: number;
  }[];
}, {
  sessionId: string;
  projectPath: string;
  inputTokens: number;
  outputTokens: number;
  cacheCreationTokens: number;
  cacheReadTokens: number;
  totalCost: number;
  lastActivity: string;
  versions: string[];
  modelsUsed: string[];
  modelBreakdowns: {
    modelName: string;
    inputTokens: number;
    outputTokens: number;
    cacheCreationTokens: number;
    cacheReadTokens: number;
    cost: number;
  }[];
}>;
/**
 * Type definition for session-based usage aggregation
 */
type SessionUsage = z.infer<typeof sessionUsageSchema>;
/**
 * Zod schema for monthly usage aggregation data
 */
declare const monthlyUsageSchema: z.ZodObject<{
  month: z.ZodBranded<z.ZodString, "MonthlyDate">;
  inputTokens: z.ZodNumber;
  outputTokens: z.ZodNumber;
  cacheCreationTokens: z.ZodNumber;
  cacheReadTokens: z.ZodNumber;
  totalCost: z.ZodNumber;
  modelsUsed: z.ZodArray<z.ZodBranded<z.ZodString, "ModelName">, "many">;
  modelBreakdowns: z.ZodArray<z.ZodObject<{
    modelName: z.ZodBranded<z.ZodString, "ModelName">;
    inputTokens: z.ZodNumber;
    outputTokens: z.ZodNumber;
    cacheCreationTokens: z.ZodNumber;
    cacheReadTokens: z.ZodNumber;
    cost: z.ZodNumber;
  }, "strip", z.ZodTypeAny, {
    modelName: string & z.BRAND<"ModelName">;
    inputTokens: number;
    outputTokens: number;
    cacheCreationTokens: number;
    cacheReadTokens: number;
    cost: number;
  }, {
    modelName: string;
    inputTokens: number;
    outputTokens: number;
    cacheCreationTokens: number;
    cacheReadTokens: number;
    cost: number;
  }>, "many">;
  project: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
  month: string & z.BRAND<"MonthlyDate">;
  inputTokens: number;
  outputTokens: number;
  cacheCreationTokens: number;
  cacheReadTokens: number;
  totalCost: number;
  modelsUsed: (string & z.BRAND<"ModelName">)[];
  modelBreakdowns: {
    modelName: string & z.BRAND<"ModelName">;
    inputTokens: number;
    outputTokens: number;
    cacheCreationTokens: number;
    cacheReadTokens: number;
    cost: number;
  }[];
  project?: string | undefined;
}, {
  month: string;
  inputTokens: number;
  outputTokens: number;
  cacheCreationTokens: number;
  cacheReadTokens: number;
  totalCost: number;
  modelsUsed: string[];
  modelBreakdowns: {
    modelName: string;
    inputTokens: number;
    outputTokens: number;
    cacheCreationTokens: number;
    cacheReadTokens: number;
    cost: number;
  }[];
  project?: string | undefined;
}>;
/**
 * Type definition for monthly usage aggregation
 */
type MonthlyUsage = z.infer<typeof monthlyUsageSchema>;
/**
 * Zod schema for weekly usage aggregation data
 */
declare const weeklyUsageSchema: z.ZodObject<{
  week: z.ZodBranded<z.ZodString, "WeeklyDate">;
  inputTokens: z.ZodNumber;
  outputTokens: z.ZodNumber;
  cacheCreationTokens: z.ZodNumber;
  cacheReadTokens: z.ZodNumber;
  totalCost: z.ZodNumber;
  modelsUsed: z.ZodArray<z.ZodBranded<z.ZodString, "ModelName">, "many">;
  modelBreakdowns: z.ZodArray<z.ZodObject<{
    modelName: z.ZodBranded<z.ZodString, "ModelName">;
    inputTokens: z.ZodNumber;
    outputTokens: z.ZodNumber;
    cacheCreationTokens: z.ZodNumber;
    cacheReadTokens: z.ZodNumber;
    cost: z.ZodNumber;
  }, "strip", z.ZodTypeAny, {
    modelName: string & z.BRAND<"ModelName">;
    inputTokens: number;
    outputTokens: number;
    cacheCreationTokens: number;
    cacheReadTokens: number;
    cost: number;
  }, {
    modelName: string;
    inputTokens: number;
    outputTokens: number;
    cacheCreationTokens: number;
    cacheReadTokens: number;
    cost: number;
  }>, "many">;
  project: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
  week: string & z.BRAND<"WeeklyDate">;
  inputTokens: number;
  outputTokens: number;
  cacheCreationTokens: number;
  cacheReadTokens: number;
  totalCost: number;
  modelsUsed: (string & z.BRAND<"ModelName">)[];
  modelBreakdowns: {
    modelName: string & z.BRAND<"ModelName">;
    inputTokens: number;
    outputTokens: number;
    cacheCreationTokens: number;
    cacheReadTokens: number;
    cost: number;
  }[];
  project?: string | undefined;
}, {
  week: string;
  inputTokens: number;
  outputTokens: number;
  cacheCreationTokens: number;
  cacheReadTokens: number;
  totalCost: number;
  modelsUsed: string[];
  modelBreakdowns: {
    modelName: string;
    inputTokens: number;
    outputTokens: number;
    cacheCreationTokens: number;
    cacheReadTokens: number;
    cost: number;
  }[];
  project?: string | undefined;
}>;
/**
 * Type definition for weekly usage aggregation
 */
type WeeklyUsage = z.infer<typeof weeklyUsageSchema>;
/**
 * Zod schema for bucket usage aggregation data
 */
declare const bucketUsageSchema: z.ZodObject<{
  bucket: z.ZodUnion<[z.ZodBranded<z.ZodString, "WeeklyDate">, z.ZodBranded<z.ZodString, "MonthlyDate">]>;
  inputTokens: z.ZodNumber;
  outputTokens: z.ZodNumber;
  cacheCreationTokens: z.ZodNumber;
  cacheReadTokens: z.ZodNumber;
  totalCost: z.ZodNumber;
  modelsUsed: z.ZodArray<z.ZodBranded<z.ZodString, "ModelName">, "many">;
  modelBreakdowns: z.ZodArray<z.ZodObject<{
    modelName: z.ZodBranded<z.ZodString, "ModelName">;
    inputTokens: z.ZodNumber;
    outputTokens: z.ZodNumber;
    cacheCreationTokens: z.ZodNumber;
    cacheReadTokens: z.ZodNumber;
    cost: z.ZodNumber;
  }, "strip", z.ZodTypeAny, {
    modelName: string & z.BRAND<"ModelName">;
    inputTokens: number;
    outputTokens: number;
    cacheCreationTokens: number;
    cacheReadTokens: number;
    cost: number;
  }, {
    modelName: string;
    inputTokens: number;
    outputTokens: number;
    cacheCreationTokens: number;
    cacheReadTokens: number;
    cost: number;
  }>, "many">;
  project: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
  bucket: (string & z.BRAND<"MonthlyDate">) | (string & z.BRAND<"WeeklyDate">);
  inputTokens: number;
  outputTokens: number;
  cacheCreationTokens: number;
  cacheReadTokens: number;
  totalCost: number;
  modelsUsed: (string & z.BRAND<"ModelName">)[];
  modelBreakdowns: {
    modelName: string & z.BRAND<"ModelName">;
    inputTokens: number;
    outputTokens: number;
    cacheCreationTokens: number;
    cacheReadTokens: number;
    cost: number;
  }[];
  project?: string | undefined;
}, {
  bucket: string;
  inputTokens: number;
  outputTokens: number;
  cacheCreationTokens: number;
  cacheReadTokens: number;
  totalCost: number;
  modelsUsed: string[];
  modelBreakdowns: {
    modelName: string;
    inputTokens: number;
    outputTokens: number;
    cacheCreationTokens: number;
    cacheReadTokens: number;
    cost: number;
  }[];
  project?: string | undefined;
}>;
/**
 * Type definition for bucket usage aggregation
 */
type BucketUsage = z.infer<typeof bucketUsageSchema>;
/**
 * Formats a date string to YYYY-MM-DD format
 * @param dateStr - Input date string
 * @param timezone - Optional timezone to use for formatting
 * @param locale - Optional locale to use for formatting (defaults to 'en-CA' for YYYY-MM-DD format)
 * @returns Formatted date string in YYYY-MM-DD format
 */
declare function formatDate(dateStr: string, timezone?: string, locale?: string): string;
/**
 * Formats a date string to compact format with year on first line and month-day on second
 * @param dateStr - Input date string
 * @param timezone - Timezone to use for formatting (pass undefined to use system timezone)
 * @param locale - Locale to use for formatting
 * @returns Formatted date string with newline separator (YYYY\nMM-DD)
 */
declare function formatDateCompact(dateStr: string, timezone: string | undefined, locale: string): string;
/**
 * Create a unique identifier for deduplication using message ID and request ID
 */
declare function createUniqueHash(data: UsageData): string | null;
/**
 * Extract the earliest timestamp from a JSONL file
 * Scans through the file until it finds a valid timestamp
 */
declare function getEarliestTimestamp(filePath: string): Promise<Date | null>;
/**
 * Sort files by their earliest timestamp
 * Files without valid timestamps are placed at the end
 */
declare function sortFilesByTimestamp(files: string[]): Promise<string[]>;
/**
 * Calculates cost for a single usage data entry based on the specified cost calculation mode
 * @param data - Usage data entry
 * @param mode - Cost calculation mode (auto, calculate, or display)
 * @param fetcher - Pricing fetcher instance for calculating costs from tokens
 * @returns Calculated cost in USD
 */
declare function calculateCostForEntry(data: UsageData, mode: CostMode, fetcher: PricingFetcher): Promise<number>;
/**
 * Get Claude Code usage limit expiration date
 * @param data - Usage data entry
 * @returns Usage limit expiration date
 */
declare function getUsageLimitResetTime(data: UsageData): Date | null;
/**
 * Result of glob operation with base directory information
 */
type GlobResult = {
  file: string;
  baseDir: string;
};
/**
 * Glob files from multiple Claude paths in parallel
 * @param claudePaths - Array of Claude base paths
 * @returns Array of file paths with their base directories
 */
declare function globUsageFiles(claudePaths: string[]): Promise<GlobResult[]>;
/**
 * Date range filter for limiting usage data by date
 */
type DateFilter = {
  since?: string; // YYYYMMDD format
  until?: string; // YYYYMMDD format
};
type WeekDay = TupleToUnion<typeof WEEK_DAYS>;
/**
 * Configuration options for loading usage data
 */
type LoadOptions = {
  claudePath?: string; // Custom path to Claude data directory
  mode?: CostMode; // Cost calculation mode
  order?: SortOrder; // Sort order for dates
  offline?: boolean; // Use offline mode for pricing
  sessionDurationHours?: number; // Session block duration in hours
  groupByProject?: boolean; // Group data by project instead of aggregating
  project?: string; // Filter to specific project name
  startOfWeek?: WeekDay; // Start of week for weekly aggregation
  timezone?: string; // Timezone for date grouping (e.g., 'UTC', 'America/New_York'). Defaults to system timezone
  locale?: string; // Locale for date/time formatting (e.g., 'en-US', 'ja-JP'). Defaults to 'en-US'
} & DateFilter;
/**
 * Loads and aggregates Claude usage data by day
 * Processes all JSONL files in the Claude projects directory and groups usage by date
 * @param options - Optional configuration for loading and filtering data
 * @returns Array of daily usage summaries sorted by date
 */
declare function loadDailyUsageData(options?: LoadOptions): Promise<DailyUsage[]>;
/**
 * Loads and aggregates Claude usage data by session
 * Groups usage data by project path and session ID based on file structure
 * @param options - Optional configuration for loading and filtering data
 * @returns Array of session usage summaries sorted by last activity
 */
declare function loadSessionData(options?: LoadOptions): Promise<SessionUsage[]>;
/**
 * Loads and aggregates Claude usage data by month
 * Uses daily usage data as the source and groups by month
 * @param options - Optional configuration for loading and filtering data
 * @returns Array of monthly usage summaries sorted by month
 */
declare function loadMonthlyUsageData(options?: LoadOptions): Promise<MonthlyUsage[]>;
declare function loadWeeklyUsageData(options?: LoadOptions): Promise<WeeklyUsage[]>;
/**
 * Load usage data for a specific session by sessionId
 * Searches for a JSONL file named {sessionId}.jsonl in all Claude project directories
 * @param sessionId - The session ID to load data for (matches the JSONL filename)
 * @param options - Options for loading data
 * @param options.mode - Cost calculation mode (auto, calculate, display)
 * @param options.offline - Whether to use offline pricing data
 * @returns Usage data for the specific session or null if not found
 */
declare function loadSessionUsageById(sessionId: string, options?: {
  mode?: CostMode;
  offline?: boolean;
}): Promise<{
  totalCost: number;
  entries: UsageData[];
} | null>;
declare function loadBucketUsageData(groupingFn: (data: DailyUsage) => Bucket, options?: LoadOptions): Promise<BucketUsage[]>;
/**
 * Calculate context tokens from transcript file using improved JSONL parsing
 * Based on the Python reference implementation for better accuracy
 * @param transcriptPath - Path to the transcript JSONL file
 * @returns Object with context tokens info or null if unavailable
 */
declare function calculateContextTokens(transcriptPath: string): Promise<{
  inputTokens: number;
  percentage: number;
  contextLimit: number;
} | null>;
/**
 * Loads usage data and organizes it into session blocks (typically 5-hour billing periods)
 * Processes all usage data and groups it into time-based blocks for billing analysis
 * @param options - Optional configuration including session duration and filtering
 * @returns Array of session blocks with usage and cost information
 */
declare function loadSessionBlockData(options?: LoadOptions): Promise<SessionBlock[]>;
//#endregion
export { BucketUsage, DailyUsage, DateFilter, GlobResult, LoadOptions, ModelBreakdown, MonthlyUsage, SessionUsage, UsageData, WeeklyUsage, bucketUsageSchema, calculateContextTokens, calculateCostForEntry, createUniqueHash, dailyUsageSchema, extractProjectFromPath, formatDate, formatDateCompact, getClaudePaths, getContextUsageThresholds, getEarliestTimestamp, getUsageLimitResetTime, globUsageFiles, loadBucketUsageData, loadDailyUsageData, loadMonthlyUsageData, loadSessionBlockData, loadSessionData, loadSessionUsageById, loadWeeklyUsageData, modelBreakdownSchema, monthlyUsageSchema, sessionUsageSchema, sortFilesByTimestamp, transcriptMessageSchema, transcriptUsageSchema, usageDataSchema, weeklyUsageSchema };