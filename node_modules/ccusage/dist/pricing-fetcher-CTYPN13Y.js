import { modelPricingSchema } from "./_types-C0oFKDO-.js";
import { logger } from "./logger-dT_AJeHG.js";
import { createRequire } from "node:module";
import path from "node:path";
import F, { homedir } from "node:os";
var __create = Object.create, __defProp = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __getOwnPropNames = Object.getOwnPropertyNames, __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty, __commonJSMin = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports), __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) if (key = keys[i], !__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
}, __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod)), __require = /* @__PURE__ */ createRequire(import.meta.url);
const isFailure = (result) => "Failure" === result.type, isPromise = (value) => "object" == typeof value && null !== value && "then" in value && "function" == typeof value.then && "catch" in value && "function" == typeof value.catch, andThen = (fn) => (result) => {
	const apply = (r) => {
		return isFailure(r) ? r : fn(r.value);
	};
	return isPromise(result) ? result.then(apply) : apply(result);
}, andThrough = (fn) => (result) => {
	const apply = (r) => {
		if (isFailure(r)) return r;
		const next = fn(r.value);
		return isPromise(next) ? next.then((n) => {
			return isFailure(n) ? n : r;
		}) : isFailure(next) ? next : r;
	};
	return isPromise(result) ? result.then(apply) : apply(result);
}, isSuccess = (result) => "Success" === result.type, succeed = (...args) => {
	const value = args[0];
	return void 0 === value ? { type: "Success" } : isPromise(value) ? value.then((value$1) => ({
		type: "Success",
		value: value$1
	})) : {
		type: "Success",
		value
	};
}, fail = (...args) => {
	const error = args[0];
	return void 0 === error ? { type: "Failure" } : isPromise(error) ? error.then((error$1) => ({
		type: "Failure",
		error: error$1
	})) : {
		type: "Failure",
		error
	};
}, inspect = (fn) => (result) => {
	const apply = (r) => {
		if (isSuccess(r)) fn(r.value);
		return r;
	};
	return isPromise(result) ? result.then(apply) : apply(result);
}, inspectError = (fn) => (result) => {
	const apply = (r) => {
		if (isFailure(r)) fn(r.error);
		return r;
	};
	return isPromise(result) ? result.then(apply) : apply(result);
}, map = (fn) => (result) => {
	const apply = (r) => {
		return isFailure(r) ? r : succeed(fn(r.value));
	};
	return isPromise(result) ? result.then(apply) : apply(result);
}, orElse = (fn) => (result) => {
	const apply = (r) => {
		return isSuccess(r) ? r : fn(r.error);
	};
	return isPromise(result) ? result.then(apply) : apply(result);
}, pipe = (value, ...functions) => {
	let next = value;
	for (const func of functions) next = func(next);
	return next;
}, try_ = (options) => {
	return isPromise(options.try) ? "safe" in options && options.safe ? succeed(options.try) : options.try.then((value) => succeed(value), (error) => fail(options.catch(error))) : (...args) => {
		try {
			const output = options.try(...args);
			if (isPromise(output)) {
				const promise = succeed(output);
				return "safe" in options && options.safe ? promise : promise.catch((error) => fail(options.catch(error)));
			}
			return succeed(output);
		} catch (error) {
			if ("safe" in options && options.safe) throw error;
			return fail(options.catch(error));
		}
	};
}, homeDirectory = F.homedir(), { env } = process, xdgData = env.XDG_DATA_HOME || (homeDirectory ? path.join(homeDirectory, ".local", "share") : void 0), xdgConfig = env.XDG_CONFIG_HOME || (homeDirectory ? path.join(homeDirectory, ".config") : void 0), xdgState = env.XDG_STATE_HOME || (homeDirectory ? path.join(homeDirectory, ".local", "state") : void 0), xdgCache = env.XDG_CACHE_HOME || (homeDirectory ? path.join(homeDirectory, ".cache") : void 0), xdgRuntime = env.XDG_RUNTIME_DIR || void 0, xdgDataDirectories = (env.XDG_DATA_DIRS || "/usr/local/share/:/usr/share/").split(":");
if (xdgData) xdgDataDirectories.unshift(xdgData);
const xdgConfigDirectories = (env.XDG_CONFIG_DIRS || "/etc/xdg").split(":");
if (xdgConfig) xdgConfigDirectories.unshift(xdgConfig);
const LITELLM_PRICING_URL = "https://raw.githubusercontent.com/BerriAI/litellm/main/model_prices_and_context_window.json", DEFAULT_RECENT_DAYS = 3, BLOCKS_WARNING_THRESHOLD = .8, BLOCKS_COMPACT_WIDTH_THRESHOLD = 120, BLOCKS_DEFAULT_TERMINAL_WIDTH = 120, DEBUG_MATCH_THRESHOLD_PERCENT = .1, USER_HOME_DIR = homedir(), XDG_CONFIG_DIR = xdgConfig ?? `${USER_HOME_DIR}/.config`, DEFAULT_CLAUDE_CODE_PATH = ".claude", DEFAULT_CLAUDE_CONFIG_PATH = `${XDG_CONFIG_DIR}/claude`, CLAUDE_CONFIG_DIR_ENV = "CLAUDE_CONFIG_DIR", PROJECT_ALIASES_ENV = "CCUSAGE_PROJECT_ALIASES", CLAUDE_PROJECTS_DIR_NAME = "projects", USAGE_DATA_GLOB_PATTERN = "**/*.jsonl", MCP_DEFAULT_PORT = 8080, DEFAULT_REFRESH_INTERVAL_SECONDS = 1, MIN_REFRESH_INTERVAL_SECONDS = 1, MAX_REFRESH_INTERVAL_SECONDS = 60, MIN_RENDER_INTERVAL_MS = 16, BURN_RATE_THRESHOLDS = {
	HIGH: 1e3,
	MODERATE: 500
}, CONTEXT_LIMIT = 2e5, DEFAULT_CONTEXT_USAGE_THRESHOLDS = {
	LOW: 50,
	MEDIUM: 80
}, CONTEXT_LOW_THRESHOLD_ENV = "CCUSAGE_CONTEXT_LOW_THRESHOLD", CONTEXT_MEDIUM_THRESHOLD_ENV = "CCUSAGE_CONTEXT_MEDIUM_THRESHOLD", WEEK_DAYS = [
	"sunday",
	"monday",
	"tuesday",
	"wednesday",
	"thursday",
	"friday",
	"saturday"
];
var require_usingCtx = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function _usingCtx() {
		var r = "function" == typeof SuppressedError ? SuppressedError : function(r$1, e$1) {
			var n$1 = Error();
			return n$1.name = "SuppressedError", n$1.error = r$1, n$1.suppressed = e$1, n$1;
		}, e = {}, n = [];
		function using(r$1, e$1) {
			if (null != e$1) {
				if (Object(e$1) !== e$1) throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");
				if (r$1) var o = e$1[Symbol.asyncDispose || Symbol["for"]("Symbol.asyncDispose")];
				if (void 0 === o && (o = e$1[Symbol.dispose || Symbol["for"]("Symbol.dispose")], r$1)) var t = o;
				if ("function" != typeof o) throw new TypeError("Object is not disposable.");
				t && (o = function o$1() {
					try {
						t.call(e$1);
					} catch (r$2) {
						return Promise.reject(r$2);
					}
				}), n.push({
					v: e$1,
					d: o,
					a: r$1
				});
			} else r$1 && n.push({
				d: e$1,
				a: r$1
			});
			return e$1;
		}
		return {
			e,
			u: using.bind(null, !1),
			a: using.bind(null, !0),
			d: function d() {
				var o, t = this.e, s = 0;
				function next() {
					for (; o = n.pop();) try {
						if (!o.a && 1 === s) return s = 0, n.push(o), Promise.resolve().then(next);
						if (o.d) {
							var r$1 = o.d.call(o.v);
							if (o.a) return s |= 2, Promise.resolve(r$1).then(next, err);
						} else s |= 1;
					} catch (r$2) {
						return err(r$2);
					}
					if (1 === s) return t !== e ? Promise.reject(t) : Promise.resolve();
					if (t !== e) throw t;
				}
				function err(n$1) {
					return t = t !== e ? new r(n$1, t) : n$1, next();
				}
				return next();
			}
		};
	}
	module.exports = _usingCtx, module.exports.__esModule = true, module.exports["default"] = module.exports;
})), import_usingCtx = /* @__PURE__ */ __toESM(require_usingCtx(), 1), PricingFetcher = class {
	cachedPricing = null;
	offline;
	constructor(offline = false) {
		this.offline = offline;
	}
	[Symbol.dispose]() {
		this.clearCache();
	}
	clearCache() {
		this.cachedPricing = null;
	}
	loadOfflinePricing = try_({
		try: async () => {
			const pricing = new Map(Object.entries({
				"claude-3-haiku-20240307": {
					"input_cost_per_token": 25e-8,
					"output_cost_per_token": 125e-8,
					"cache_creation_input_token_cost": 3e-7,
					"cache_read_input_token_cost": 3e-8
				},
				"claude-3-5-haiku-20241022": {
					"input_cost_per_token": 8e-7,
					"output_cost_per_token": 4e-6,
					"cache_creation_input_token_cost": 1e-6,
					"cache_read_input_token_cost": 8e-8
				},
				"claude-3-5-haiku-latest": {
					"input_cost_per_token": 1e-6,
					"output_cost_per_token": 5e-6,
					"cache_creation_input_token_cost": 125e-8,
					"cache_read_input_token_cost": 1e-7
				},
				"claude-3-opus-latest": {
					"input_cost_per_token": 15e-6,
					"output_cost_per_token": 75e-6,
					"cache_creation_input_token_cost": 1875e-8,
					"cache_read_input_token_cost": 15e-7
				},
				"claude-3-opus-20240229": {
					"input_cost_per_token": 15e-6,
					"output_cost_per_token": 75e-6,
					"cache_creation_input_token_cost": 1875e-8,
					"cache_read_input_token_cost": 15e-7
				},
				"claude-3-5-sonnet-latest": {
					"input_cost_per_token": 3e-6,
					"output_cost_per_token": 15e-6,
					"cache_creation_input_token_cost": 375e-8,
					"cache_read_input_token_cost": 3e-7
				},
				"claude-3-5-sonnet-20240620": {
					"input_cost_per_token": 3e-6,
					"output_cost_per_token": 15e-6,
					"cache_creation_input_token_cost": 375e-8,
					"cache_read_input_token_cost": 3e-7
				},
				"claude-opus-4-20250514": {
					"input_cost_per_token": 15e-6,
					"output_cost_per_token": 75e-6,
					"cache_creation_input_token_cost": 1875e-8,
					"cache_read_input_token_cost": 15e-7
				},
				"claude-opus-4-1": {
					"input_cost_per_token": 15e-6,
					"output_cost_per_token": 75e-6,
					"cache_creation_input_token_cost": 1875e-8,
					"cache_read_input_token_cost": 15e-7
				},
				"claude-opus-4-1-20250805": {
					"input_cost_per_token": 15e-6,
					"output_cost_per_token": 75e-6,
					"cache_creation_input_token_cost": 1875e-8,
					"cache_read_input_token_cost": 15e-7
				},
				"claude-sonnet-4-20250514": {
					"input_cost_per_token": 3e-6,
					"output_cost_per_token": 15e-6,
					"cache_creation_input_token_cost": 375e-8,
					"cache_read_input_token_cost": 3e-7
				},
				"claude-4-opus-20250514": {
					"input_cost_per_token": 15e-6,
					"output_cost_per_token": 75e-6,
					"cache_creation_input_token_cost": 1875e-8,
					"cache_read_input_token_cost": 15e-7
				},
				"claude-4-sonnet-20250514": {
					"input_cost_per_token": 3e-6,
					"output_cost_per_token": 15e-6,
					"cache_creation_input_token_cost": 375e-8,
					"cache_read_input_token_cost": 3e-7
				},
				"claude-3-7-sonnet-latest": {
					"input_cost_per_token": 3e-6,
					"output_cost_per_token": 15e-6,
					"cache_creation_input_token_cost": 375e-8,
					"cache_read_input_token_cost": 3e-7
				},
				"claude-3-7-sonnet-20250219": {
					"input_cost_per_token": 3e-6,
					"output_cost_per_token": 15e-6,
					"cache_creation_input_token_cost": 375e-8,
					"cache_read_input_token_cost": 3e-7
				},
				"claude-3-5-sonnet-20241022": {
					"input_cost_per_token": 3e-6,
					"output_cost_per_token": 15e-6,
					"cache_creation_input_token_cost": 375e-8,
					"cache_read_input_token_cost": 3e-7
				}
			}));
			return this.cachedPricing = pricing, pricing;
		},
		catch: (error) => new Error("Failed to load offline pricing data", { cause: error })
	});
	async handleFallbackToCachedPricing(originalError) {
		return logger.warn("Failed to fetch model pricing from LiteLLM, falling back to cached pricing data"), logger.debug("Fetch error details:", originalError), pipe(this.loadOfflinePricing(), inspect((pricing) => {
			logger.info(`Using cached pricing data for ${pricing.size} models`);
		}), inspectError((error) => {
			logger.error("Failed to load cached pricing data as fallback:", error), logger.error("Original fetch error:", originalError);
		}));
	}
	async ensurePricingLoaded() {
		return pipe(this.cachedPricing != null ? succeed(this.cachedPricing) : fail(/* @__PURE__ */ new Error("Cached pricing not available")), orElse(async () => {
			return this.offline ? this.loadOfflinePricing() : (logger.warn("Fetching latest model pricing from LiteLLM..."), pipe(try_({
				try: fetch(LITELLM_PRICING_URL),
				catch: (error) => new Error("Failed to fetch model pricing from LiteLLM", { cause: error })
			}), andThrough((response) => {
				return response.ok ? succeed() : fail(/* @__PURE__ */ new Error(`Failed to fetch pricing data: ${response.statusText}`));
			}), andThen(async (response) => try_({
				try: response.json(),
				catch: (error) => new Error("Failed to parse pricing data", { cause: error })
			})), map((data) => {
				const pricing = /* @__PURE__ */ new Map();
				for (const [modelName, modelData] of Object.entries(data)) if (typeof modelData === "object" && modelData !== null) {
					const parsed = modelPricingSchema.safeParse(modelData);
					if (parsed.success) pricing.set(modelName, parsed.data);
				}
				return pricing;
			}), inspect((pricing) => {
				this.cachedPricing = pricing, logger.info(`Loaded pricing for ${pricing.size} models`);
			}), orElse(async (error) => this.handleFallbackToCachedPricing(error))));
		}));
	}
	async fetchModelPricing() {
		return this.ensurePricingLoaded();
	}
	async getModelPricing(modelName) {
		return pipe(this.ensurePricingLoaded(), map((pricing) => {
			const directMatch = pricing.get(modelName);
			if (directMatch != null) return directMatch;
			const variations = [
				modelName,
				`anthropic/${modelName}`,
				`claude-3-5-${modelName}`,
				`claude-3-${modelName}`,
				`claude-${modelName}`
			];
			for (const variant of variations) {
				const match = pricing.get(variant);
				if (match != null) return match;
			}
			const lowerModel = modelName.toLowerCase();
			for (const [key, value] of pricing) if (key.toLowerCase().includes(lowerModel) || lowerModel.includes(key.toLowerCase())) return value;
			return null;
		}));
	}
	async calculateCostFromTokens(tokens, modelName) {
		return pipe(this.getModelPricing(modelName), map((pricing) => pricing == null ? 0 : this.calculateCostFromPricing(tokens, pricing)));
	}
	calculateCostFromPricing(tokens, pricing) {
		let cost = 0;
		if (pricing.input_cost_per_token != null) cost += tokens.input_tokens * pricing.input_cost_per_token;
		if (pricing.output_cost_per_token != null) cost += tokens.output_tokens * pricing.output_cost_per_token;
		if (tokens.cache_creation_input_tokens != null && pricing.cache_creation_input_token_cost != null) cost += tokens.cache_creation_input_tokens * pricing.cache_creation_input_token_cost;
		if (tokens.cache_read_input_tokens != null && pricing.cache_read_input_token_cost != null) cost += tokens.cache_read_input_tokens * pricing.cache_read_input_token_cost;
		return cost;
	}
};
export { BLOCKS_COMPACT_WIDTH_THRESHOLD, BLOCKS_DEFAULT_TERMINAL_WIDTH, BLOCKS_WARNING_THRESHOLD, BURN_RATE_THRESHOLDS, CLAUDE_CONFIG_DIR_ENV, CLAUDE_PROJECTS_DIR_NAME, CONTEXT_LIMIT, CONTEXT_LOW_THRESHOLD_ENV, CONTEXT_MEDIUM_THRESHOLD_ENV, DEBUG_MATCH_THRESHOLD_PERCENT, DEFAULT_CLAUDE_CODE_PATH, DEFAULT_CLAUDE_CONFIG_PATH, DEFAULT_CONTEXT_USAGE_THRESHOLDS, DEFAULT_RECENT_DAYS, DEFAULT_REFRESH_INTERVAL_SECONDS, MAX_REFRESH_INTERVAL_SECONDS, MCP_DEFAULT_PORT, MIN_REFRESH_INTERVAL_SECONDS, MIN_RENDER_INTERVAL_MS, PROJECT_ALIASES_ENV, PricingFetcher, USAGE_DATA_GLOB_PATTERN, USER_HOME_DIR, WEEK_DAYS, __commonJSMin, __require, __toESM, isFailure, isPromise, require_usingCtx, try_ };
